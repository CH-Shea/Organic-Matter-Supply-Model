---
title: "AA-CSIA-based Food Web Model: Analyzing data from wild zooplankton"
author: "Connor Shea"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
output: 
  #html_document: 
  bookdown::html_document2:  
    self-contained: yes
    theme: cerulean #paper #cosmo #journal #readable
    toc: true
    smooth_scroll: true
    toc_depth: 3
    toc_float: true
    number_sections: true
    fig_caption: yes
    code_folding: hide
bibliography: MesoPelaZooAA.bib
csl: LnO.csl
link-citations: yes
---

```{r setup, echo=FALSE, warning=FALSE}
# This chunk sets up a working directory, loads packages, and sets global chunk
# options for the .Rmd document

rm(list=ls()) # clean up

## set working directory to the same folder that contains this .rmd file
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))

## load packages quietly
shhh <- suppressPackageStartupMessages # It's a library, so shhh!
want <- c("knitr", 
          "readxl", # for reading xl files
          "MASS", # some statistics including lda
          "vegan", # ecology statistics
          "FactoMineR", # includes PCA function and utilities
          "factoextra", # extra utilities for FactoMineR
          "runjags", # To run Bayesian models
          "TruncatedDistributions", # To generate truncate porbability distributions
          "coda",  
          "DT", # makes nice sortable tables
          "openxlsx", # writes to .xlsx files
          "compositions", 
          "kableExtra",
          "zeallot", 
          "magrittr", 
          "DirichletReg", 
          "Ternary", 
          "png",
          "ggplot2",
          "ggpubr",
          "ggstance", # for vertical position dodging
          "ggtern", # for ternary plots in ggplot2
          "ggforce", # for specific extra plotting capabilities (facet_row())
          "plotly",
          "gridExtra",
          "graphics",
          "reshape2")
for (pkg in want) shhh(library(pkg, character.only=TRUE))

## set some chunk options
gr <- (1+sqrt(5))/2 # golden ratio, for figures
opts_chunk$set(comment="  ",
               fig.asp=0.9/gr,       # <--- gr used here
               fig.align="center",
               #echo=FALSE,
               cache=c(TRUE, FALSE)[1], 
               eval.after="fig.cap", # for dynamic captions
               collapse=TRUE, 
               dev="png", # svg, pdf, jpg, tiff
               fig.width=7.0,
               out.width="95%"
               )

## Kruschke's utility functions (edited by NF)
if (c(TRUE,FALSE)[1]) source("DBDA2E-utilities.R") 

## a couple of lines we need to run every time we knit
# setting the ggplot theme
theme_set(theme_classic2()+
            theme(panel.grid.major.x = element_line(colour = "grey95"),
                  panel.grid.major.y = element_line(colour = "grey95")))
# defining a ggplot object to remove the x axis
no.x.axis <- theme(axis.title.x=element_blank(),
                   axis.text.x=element_blank(),
                   axis.ticks.x=element_blank())
# defining a ggplot object to remove the y axis
no.y.axis <- theme(axis.title.y=element_blank(),
                   axis.text.y=element_blank(),
                   axis.ticks.y=element_blank())

## fresh start? If FALSE (select 2 in hard bracket), will only rerun a chunk if 
## changes are detected within the text of that chunk.
rmCache <- c(TRUE, FALSE)[1] 
if (rmCache) {
  tfn <- knitr::current_input()              # name of this file
  tfn <- substr(tfn, 1, nchar(tfn)-4)        # Remove the ".Rmd"
  tfn_cache <- paste0(tfn, "_cache")         # Append "_cache" to it
  if (file.exists(tfn_cache))                # If the cache exists...
    unlink(tfn_cache, recursive=TRUE)        # ...delete it.
}
```  

<!-- The following commands provide a shorthand for common symbols when used in math mode. -->

\newcommand{\um}{\ \mu \mathrm{ m}}
\newcommand{\mm}{\mathrm{\ mm}}
\newcommand{\m}{\mathrm{\ m}}
\newcommand{\N}{\mathrm{^{15}\text{N}}}
\newcommand{\dN}{\mathrm{\delta^{15}\text{N}}}
\newcommand{\dNAA}{\mathrm{\delta^{15}\text{N}_\text{AA}}}
\newcommand{\dNSAA}{\mathrm{\delta^{15}\text{N}_\text{SAA}}}
\newcommand{\dNTAA}{\mathrm{\delta^{15}\text{N}_\text{TAA}}}
\newcommand{\dNtr}{\mathrm{\delta^{15}\text{N}_\text{tr}}}
\newcommand{\dNsrc}{\mathrm{\delta^{15}\text{N}_\text{src}}}
\newcommand{\dNphe}{\mathrm{\delta^{15}N_{phe}}}
\newcommand{\dNthr}{\mathrm{\delta^{15}N_{thr}}}
\newcommand{\dNala}{\mathrm{\delta^{15}N_{ala}}}
\newcommand{\dNglx}{\mathrm{\delta^{15}N_{glx}}}
\newcommand{\dNThrPhe}{\mathrm{\delta^{15}N_{thr-phe}}}
\newcommand{\dNAlaPhe}{\mathrm{\delta^{15}N_{ala-phe}}}
\newcommand{\dNglxphe}{\mathrm{\delta^{15}N_{glx-phe}}}
\newcommand{\DN}{\mathrm{\Delta^{15}\text{N}}}
\newcommand{\DNAA}{\mathrm{\Delta^{15}\text{N}_\text{AA}}}
\newcommand{\C}{\mathrm{^{13}\text{C}}}
\newcommand{\dC}{\mathrm{\delta^{13}\text{C}}}
\newcommand{\dCAA}{\mathrm{\delta^{13}\text{C}_\text{AA}}}
\newcommand{\dCEAA}{\mathrm{\delta^{13}\text{C}_\text{EAA}}}
\newcommand{\dCNAA}{\mathrm{\delta^{13}\text{C}_\text{NAA}}}
\newcommand{\permil}{‰}
\newcommand{\degree}{°}
\newcommand{\TP}{\mathrm{TP}}
\newcommand{\TPala}{\mathrm{TP_{ala-phe}}}
\newcommand{\TPglx}{\mathrm{TP_{glx-phe}}}
\newcommand{\TPts}{\mathrm{TP_{tr-src}}}
\newcommand{\dTP}{\mathrm{\Delta TP_{ala-glx}}}

# Summary {-}  
The purpose of this notebook is to assess isotopic separation of organic matter sources in a particular setting, and then use an AA-CSIA-based food web model to diagnose the relative importance of those sources to a food web or higher order consumer. To assess the models efficacy in a given environment, it should first be tested on simulated data with known ecological parameters.

This notebook is composed of the following sections:

  1. In the Setup section the user will input relevant data and inform the notebook with key parameters regarding how that data should be processed.
  2. In the Source Separation section, multivariate analysis will be used to assess the extent to which sources of organic matter can be uniquely identified via the isotopic data supplied.
  3. In the Selecting Zooplankton Data section, zooplankton data will be imported and processed.
  4. In the Solving Food Web Model section, the food web model will be fit and its performance assessed via simple diagnostics.
  5. In the Visualizing Results section, pmodel posteriors will be plotted.

The model code contained herein represents the base code for our stable isotope-based food web model as of 8/2/2024.

# Setup {-}

In this first few chunks, the user should enter all of the basic information that the model code will need to proceed with analysis.

The first chunk identifies tracers to be included in the model and how to treat them.

```{r identifying_tracers}

## SPECIFYING TRACERS TO BE USED IN MODEL ##

## Will amino acid δ15N data be included? (T/F)
include_d15N <- TRUE

## Will amino acid δ13C data be included? (T/F)
include_d13C <- FALSE
## Should essential amino acid δ13C data be mean normalized?
meannorm_d13C <- TRUE

# If using δ15N values in model
if(include_d15N == TRUE) {
  ## Which amino acid δ15N values should be included in the model? 
  ## These amino acids won't necessarily be used in the mixing model, but their values at the base of th food web will be calculated
  # Specify the column names of all amino acid d15N values that will be included in the model and their standard deviations (should be consistent with column names in data file)
  tracers_d15N <- c("d15NGlx","d15NAsx","d15NAla","d15NPro","d15NGly","d15NSer","d15NPhe","d15NLys","d15NThr")
  SDtracers_d15N <- c("SDd15NGlx","SDd15NAsx","SDd15NAla","SDd15NPro","SDd15NGly","SDd15NSer","SDd15NPhe","SDd15NLys","SDd15NThr")
} else {
  tracers_d15N <- c()
  SDtracers_d15N <- c()
}
# If using δ13C values in model
if(include_d13C == TRUE) {
  ## Which essential amino acid δ13C values should be included in the model? 
  ## These amino acids won't necessarily be used in the mxing model, but their values at the base of th food web will be calculated
  # Specify the column names of all amino acid d15N values that will be included in the model and their standard deviations (should be consistent with column names in data file)
  tracers_d13C <- c("d13CThr","d13CVal","d13CLeu","d13CIle","d13CPhe")
  ## What columns in the data file contain the uncertainties in those δ13C values?
  SDtracers_d13C <- c("SDd13CThr","SDd13CVal","SDd13CLeu","SDd13CIle","SDd13CPhe")
} else {
  tracers_d13C <- c()
  SDtracers_d13C <- c()
}
# Now we'll make one vector containing all of the tracers to be used in the model
tracers <- c(tracers_d15N, tracers_d13C)
SDtracers <- c(SDtracers_d15N, SDtracers_d13C)

## Of the above tracers, which ones shoud be used in the mixing model to assess sources of organic matter to the food web?
## These amino acids need to be present in the tracer list above.
## They also need to be listed in the same order as above.
tracers_mixing <- c("d15NGlx",
                    "d15NAsx",
                    "d15NAla",
                    "d15NPro",
                    # "d15NGly",
                    # "d15NSer",
                    "d15NPhe",
                    "d15NLys",
                    "d15NThr"
                    )

SDtracers_mixing <- c("SDd15NGlx",
                      "SDd15NAsx",
                      "SDd15NAla",
                      "SDd15NPro",
                      # "SDd15NGly",
                      # "SDd15NSer",
                      "SDd15NPhe",
                      "SDd15NLys",
                      "SDd15NThr"
                      )


## SPECIFYING TDFS TO BE USED IN MODEL ##

# If using δ15N values in model
if(include_d15N == TRUE) {
  ## What TDFs and SDs should be used to describe amino acid δ15N fractionation in
  ## metazoans?
  ## Note that these TDFs should NOT be normalized to any source amino acid.
  TDF_meta <- data.frame("d15NAla" = 6.3, "SDd15NAla" = 2.6,
                         "d15NGly" = 2.9, "SDd15NGly" = 3.1,
                         "d15NThr" =-4.9, "SDd15NThr" = 3.5,
                         "d15NSer" = 2.6, "SDd15NSer" = 3.2,
                         "d15NVal" = 4.4, "SDd15NVal" = 2.6,
                         "d15NLeu" = 5.6, "SDd15NLeu" = 2.4,
                         "d15NIle" = 5.5, "SDd15NIle" = 2.4,
                         "d15NPro" = 5.8, "SDd15NPro" = 1.7,
                         "d15NAsx" = 5.7, "SDd15NAsx" = 1.9,
                         "d15NMet" = 1.6, "SDd15NMet" = 2.6,
                         "d15NGlx" = 8.0, "SDd15NGlx" = 1.7,
                         "d15NPhe" = 0.3, "SDd15NPhe" = 0.5,
                         "d15NTyr" = NA , "SDd15NTyr" = NA,
                         "d15NLys" = 1.2, "SDd15NLys" = 1.2)
  
  ## What TDFs and SDs should be used to describe amino acid δ15N fractionation in
  ## protozoans?
  # Note that these TDFs should NOT be normalized to any source amino acid.
  TDF_proto = data.frame("d15NAla" = 6.3, "SDd15NAla" = 2.6,
                         "d15NGly" = 2.9, "SDd15NGly" = 3.1,
                         "d15NThr" =-2.1, "SDd15NThr" = 1.0,
                         "d15NSer" = 2.6, "SDd15NSer" = 3.2,
                         "d15NVal" = 0.7, "SDd15NVal" = 1.6,
                         "d15NLeu" = 1.4, "SDd15NLeu" = 0.6,
                         "d15NIle" =-0.5, "SDd15NIle" = 2.7,
                         "d15NPro" = 5.8, "SDd15NPro" = 1.7,
                         "d15NAsx" = 0.8, "SDd15NAsx" = 1.4,
                         "d15NMet" = NA , "SDd15NMet" = NA ,
                         "d15NGlx" = 0.5, "SDd15NGlx" = 1.0,
                         "d15NPhe" = 0.3, "SDd15NPhe" = 0.5,
                         "d15NTyr" = NA , "SDd15NTyr" = NA,
                         "d15NLys" = 1.2, "SDd15NLys" = 1.2)
  
  ## Which tracers are amino acids with constant TDFs throughout the whole food web?
  tracers_constTDF <- tracers[which(tracers %in% 
                                      c("d15NAla","d15NPro","d15NGly","d15NSer","d15NPhe","d15NLys","d15NThr")
  )]
  SDtracers_constTDF <- SDtracers[which(SDtracers %in% 
                                          c("SDd15NAla","SDd15NPro","SDd15NGly","SDd15NSer","SDd15NPhe","SDd15NLys","SDd15NThr")
  )]
  ## Which amino acids take separate TDFs in the protozoan and metazoan portions of the food web?
  tracers_varTDF <- tracers[which(tracers %in% 
                                    c("d15NGlx","d15NAsx","d15NVal","d15NLeu","d15NIle")
  )]
  SDtracers_varTDF <-SDtracers[which(SDtracers %in%
                                       c("SDd15NGlx","SDd15NAsx","SDd15NVal","SDd15NLeu","SDd15NIle")
  )]
  ## list of tracers with both constant and variable TDFs
  tracers_candv <- 
    tracers[which(tracers %in% 
                    c("d15NAla","d15NGly","d15NThr","d15NPro","d15NPhe","d15NLys",
                      "d15NSer","d15NVal","d15NLeu","d15NIle","d15NAsx","d15NGlx")
  )]
  SDtracers_candv <-
    SDtracers[which(SDtracers %in%
                      c("SDd15NAla","SDd15NGly","SDd15NThr","SDd15NPro","SDd15NPhe","SDd15NLys",
                        "SDd15NSer","SDd15NVal","SDd15NLeu","SDd15NIle","SDd15NAsx","SDd15NGlx")
  )]
}

# Last we'll define some generic groups of AAs that may be useful later on.
# Update to reflect the column names in your data
# all amino acids
allAA = c("Glx", "Asx", "Ala", "Ile", "Leu", "Pro", "Val", "Gly", "Ser", "Phe", "Lys", "Thr", "SAA", "EAA")
# columns with SD
SDallAA <- c("SDGlx", "SDAsx", "SDAla", "SDIle", "SDLeu", "SDPro", "SDVal", "SDGly", "SDSer", "SDPhe", "SDLys", "SDThr", "SDSAA", "SDEAA")
# source amino acids
srcAA = c("Phe","Gly","Ser","Lys")
# columns with SD
SDsrcAA = c("SDPhe","SDGly","SDSer","SDLys")
# trophic amino acids
trAA = c("Glx", "Asx", "Ala", "Ile", "Leu", "Pro", "Val","Thr")
# columns with SD
SDtrAA = c("SDGlx", "SDAsx", "SDAla", "SDIle", "SDLeu", "SDPro", "SDVal","SDThr")

```

Next let's define any additional functions we will need to analyze this data.

```{r def-funcs}

# defining function to propagate uncertainty for mean calculations
SDmean <- function(data, na.rm = FALSE)
{
  if (prod(!is.na(data)) == 1) {
    squareds = data^2
    sumofsquareds = sum(squareds)
    root = sqrt(sumofsquareds)
    SD = root/length(as.double(data))
    return(SD)
  } else { if (na.rm == TRUE) {
    data = na.omit(data)
    squareds = data^2
    sumofsquareds = sum(squareds)
    root = sqrt(sumofsquareds)
    SD = root/length(data)
    return(SD)
  } else {
    return(NA)
  }
  }
}

# defining a function to propagate error through summing calculations
SDsum <- function(data)
{
   if (is.numeric(data) == TRUE) {
        squareds = data^2
        sumofsquareds = sum(squareds)
        root = sqrt(sumofsquareds)
        SD = root
        return(SD)
    } else {
        return(NA)
    }
}

# the mode is more diagnostic than the mean for the posteriors, so we're going to go ahead and write a function to find the point of maximum probability for a PDF
post.mode <- function(post) {
  # first calculate the density function for the posterior PDF
  # this bins the data in n bins
  post.d <- density(post, n=512*2)
  # then find the index of the bin with the highest density
  bin.index <-with(post.d, which.max(y))
  # then find the variable value of the PDF in that bin
  with(post.d, x[bin.index])
}

# defining a function to generate split violin plots using ggplot2()
GeomSplitViolin <- ggproto("GeomSplitViolin", GeomViolin, 
                           draw_group = function(self, data, ..., draw_quantiles = NULL) {
  data <- transform(data, xminv = x - violinwidth * (x - xmin), xmaxv = x + violinwidth * (xmax - x))
  grp <- data[1, "group"]
  newdata <- plyr::arrange(transform(data, x = if (grp %% 2 == 1) xminv else xmaxv), if (grp %% 2 == 1) y else -y)
  newdata <- rbind(newdata[1, ], newdata, newdata[nrow(newdata), ], newdata[1, ])
  newdata[c(1, nrow(newdata) - 1, nrow(newdata)), "x"] <- round(newdata[1, "x"])

  if (length(draw_quantiles) > 0 & !scales::zero_range(range(data$y))) {
    stopifnot(all(draw_quantiles >= 0), all(draw_quantiles <=
      1))
    quantiles <- ggplot2:::create_quantile_segment_frame(data, draw_quantiles)
    aesthetics <- data[rep(1, nrow(quantiles)), setdiff(names(data), c("x", "y")), drop = FALSE]
    aesthetics$alpha <- rep(1, nrow(quantiles))
    both <- cbind(quantiles, aesthetics)
    quantile_grob <- GeomPath$draw_panel(both, ...)
    ggplot2:::ggname("geom_split_violin", grid::grobTree(GeomPolygon$draw_panel(newdata, ...), quantile_grob))
  }
  else {
    ggplot2:::ggname("geom_split_violin", GeomPolygon$draw_panel(newdata, ...))
  }
})

geom_split_violin <- function(mapping = NULL, data = NULL, stat = "ydensity", position = "identity", ..., 
                              draw_quantiles = NULL, trim = TRUE, scale = "area", na.rm = FALSE, 
                              show.legend = NA, inherit.aes = TRUE) {
  layer(data = data, mapping = mapping, stat = stat, geom = GeomSplitViolin, 
        position = position, show.legend = show.legend, inherit.aes = inherit.aes, 
        params = list(trim = trim, scale = scale, draw_quantiles = draw_quantiles, na.rm = na.rm, ...))
}

```

Next we will need to import data for the possible sources of organic matter.

```{r Import_Source_Data, eval=TRUE, fig.asp=0.6, out.width="100%"}

## δ13C and δ15N data of organic matter sources should be stored in one, single 
## .xlsx file. 

## Columns containing amino acid δ-values and the associated standard 
## deviations should match those defined in the chunk above.

# Indicate the name of the column describing the organic matter source to which
# each sample belongs
Source_Variable <- "Group"
# Indicate the names representing each possible source of organic matter in the
# order in which you would like the referenced
Sources <- c("Surface","Large","Small","Submicron")

# List the name of any additional variables that should be stored for analysis
Additional_variables <- c("Location","Epoch","Event","Size","Depth","Type")

variables <- c(Source_Variable, Additional_variables)

## IMPORTING DATA ##
# Define the location of .xlsx file, and sheet name if multiple sheets are 
# present. If additional data beyond organic matter sources is present in this 
# file that is ok. We will subset the data below.
Data_all <- read_excel("~/University_of_Hawaii/SIA_work/EXPORTS/Data/Data Compilation/AA-CSIA_OSP.xlsx",
                             sheet = "combined")[c(variables,tracers,SDtracers)]
# Defining the preferred order in which to reference organic matter sources
Data_all[[Source_Variable]] <- factor(Data_all[[Source_Variable]], levels = c(Sources,"Mixed","Taxa"))
# Defining the preferred order in which to reference size classes
# Data_all["Size"] <- factor(Data_all[["Size"]], levels = c(
#   c("0.3-1 μm", "1-5 μm", "1-6 μm", "6-51 μm", ">51 μm", "Sediment Trap"),
#   c("0.2-0.5 mm", "0.5-1.0 mm", "1-2 mm", "2-5 mm", ">5 mm")
# ))

## FILTERING DATA ##
# In the event that not all data in data file pertains to sources of organic
# matter, or should be otherwise excluded from analysis, a subset of the data
# can be taken at this point.
Data_sources_orig <- subset(Data_all,
                       (Depth >= 206 &
                          (Group == "Large" | Group == "Small" | Group == "Submicron")) |
                         Group == "Surface")
```

```{r gap_removal}
## DEALING WITH GAPS IN THE DATA ##

# Should representative samples of organic matter end members be simulated
# from available data? (useful if a large number of samples have only δ13C or 
# δ15N data). If FALSE, samples without values for all tracers will be excluded.
simulate_rep <- FALSE # SHOULD CHOOSE FALSE BY DEFAULT

## if we chose not to simulate representative samples...
if (simulate_rep == FALSE) { 
  Data_sources <- na.omit(Data_sources_orig[c(variables,tracers,SDtracers)]) # all samples containing NAs will be removed from data
  ## we will also find the mean tracer value for each source group
  src.mn <- aggregate(Data_sources_orig[tracers], # aggregate source data
                      by=list(Group = Data_sources_orig[[Source_Variable]]), # by organic matter source group
                      FUN = mean, na.rm=TRUE)[-1] # taking a mean
  
## if we chose to simulate representative samples...
} else {
  ## first we will find the mean tracer value for each source group
  ## as well as the mean SD within each source group
  src.mn <- aggregate(Data_sources_orig[c(tracers,SDtracers)], # aggregate source data
                      by=list(Group = Data_sources_orig[[Source_Variable]]), # by organic matter source group
                      FUN = mean, na.rm=TRUE)[-1] # taking a mean
  ## Next we will find the most conservative estimate of tracer variance within 
  ## each source group
  # we will calculate the standard deviation within each population
  src.SD.pop <- aggregate(Data_sources_orig[tracers], # aggregate source data
                          by=list(Group = Data_sources_orig[[Source_Variable]]), # by organic matter source group
                          FUN = sd, na.rm=TRUE)[-1] # calculating SD within the population
  colnames(src.SD.pop) <- c(SDtracers)
  # we will also propagate analytical uncertainty through the averaging equation
  src.SD.prop <- aggregate(Data_sources_orig[SDtracers], # aggregate source data SDs
                           by=list(Group = Data_sources_orig[[Source_Variable]]), # by organic matter source group
                           FUN = SDmean, na.rm=TRUE)[-1] # calculating the SD propagated through the averaging equation
  # and we will select the greater of the two estimates of uncertainty
  src.SD <- pmax(src.SD.pop, src.SD.prop, na.rm=TRUE)
  ## Now we will simulate n samples for each organic matter source group
  nsams <- 10 # number of samples to simulate from each source
  Data_sources <- data.frame(matrix(nrow = nsams*length(Sources), ncol = length(c(tracers,SDtracers))+1)) # initializing empty data frame
  colnames(Data_sources) <- c(tracers,SDtracers,Source_Variable) # naming columns
  for (i in variables) {
    Data_sources[[i]] <- seq(1,nsams*length(Sources))
  }
  Data_sources[[Source_Variable]] <- rep(Sources,nsams)
  Data_sources[[Source_Variable]] <- factor(Data_sources[[Source_Variable]], levels = Sources)
  set.seed(222) # set seed for repeatable sample synthesis
  for (i in 1:length(tracers)) { # loop over each tracer
    Data_sources[[tracers[i]]] <- 
      rnorm(n = nsams*length(Sources), # pulling n samples from a normal distribution
            mean = src.mn[[tracers[i]]], # with a given mean
            sd = src.SD[[SDtracers[i]]]) # and given SD
  }
  for (j in 1:length(Sources)) {
    Data_sources[which(Data_sources$Group == Sources[j]),SDtracers] <- 
      src.mn[j,SDtracers]
  }
}

```

We will also mean normalize essential amino acid $\dC$ data and store the mean essential amino acid $\dC$ value, if indicated above.

```{r mean_normalization}
# If mean normalizing EAA δ13C data
if(include_d13C == TRUE & meannorm_d13C == TRUE) {
  # Calculating the mean EAA δ13C value of each sample
  MN <- rowMeans(Data_sources[tracers_d13C])
  SD <- c()
  for (i in 1:nrow(Data_sources)) {
    SD <- append(SD, SDmean(Data_sources_orig[i,SDtracers_d13C]))
  }
  # Subtracting that from the EAA δ13C values for each sample
  # and replacing raw δ13C values in main data frame with mean normalized ones
  Data_sources[tracers_d13C] <- sweep(Data_sources[tracers_d13C], 1, MN, "-")
  # Including the mean δ13C values as an additional tracer
  Data_sources$d13CEAA <- MN
  Data_sources$SDd13CEAA <- SD
  tracers <- append(tracers, "d13CEAA")
  SDtracers <- append(SDtracers, "SDd13CEAA")
  tracers_d13C <- append(tracers_d13C, "d13CEAA")
  SDtracers_d13C <- append(SDtracers_d13C, "SDd13CEAA")
}

# we'll also need the mean values of tracers in organic matter sources later...
# first calculating the mean tracer value for each organic matter source group
src.mn <- 
  aggregate(Data_sources[tracers], # aggregate source data
            by=list(Group = Data_sources[[Source_Variable]]), # by organic matter source group
            FUN = mean, na.rm=TRUE)[-1] # taking a mean
# and the SD
# we will calculate the standard deviation within each population
src.SD <- 
  aggregate(Data_sources[tracers], # aggregate source data
            by=list(Group = Data_sources[[Source_Variable]]), # by organic matter source group
            FUN = sd, na.rm=TRUE)[-1] # calculating SD within the population
```

# Assessing source separation {-}

First lets visualize the $\dN$ and $\dC$ values of each amino acid in each organic matter source.

```{r AA_Plots_Sources, dpi=300, fig.asp=0.4, fig.width=8.5}
if (include_d13C == TRUE) {
  sources.dC.long <- 
    melt(Data_sources, id.vars=c(variables), measure.vars = tracers_d13C,
         variable.name="AA")
  sources.dC.long$AA <- sub('....','',sources.dC.long$AA)
  sources.dC.long$Isotope<- "d13C"
  if (include_d15N == FALSE) {
    sources.long <- sources.dC.long
  }
}
if (include_d15N == TRUE) {
  sources.dN.long <- 
    melt(Data_sources, id.vars=c(variables), measure.vars = tracers_d15N,
         variable.name="AA")
  sources.dN.long$AA <- sub('....','',sources.dN.long$AA)
  sources.dN.long$Isotope<- "d15N"
  if (include_d13C == FALSE) {
    sources.long <- sources.dN.long
  }
}
if (include_d13C == include_d15N) {
  sources.long <- rbind(sources.dN.long,sources.dC.long)
}
# Defining the preferred order in which to reference amino acids
sources.long$AA <- factor(sources.long$AA, levels = allAA)

AA_plots <-
  ggplot(sources.long, aes(x = AA, y = value, color = Group, group=Group))+
  geom_point(alpha=0.4, position = position_dodge(width = 0.8))+
  ylab(expression(delta^{15}*N*"   or   "*delta^{13}*C*" (\u2030)"))+
  labs(color="Organic Matter Source", shape="Food Web Base", fill="Zooplankton Samples")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.3, hjust=1))+
  facet_row(~Isotope, scales="free", space="free")
AA_plots
```

Next, to visualize the between group patterns in the data we will do some multivariate analyses. We'll start by carrying out a PCA. This should give us a decent of idea of what kind of if between-group separation is a major component of variation in this data set. It will also help us visualize which tracers are driving separation between certain organic matter sources and which are providing redundant information.

```{r PCA_sources, dpi=300, fig.asp=0.6, out.width="90%"}
# Fitting PCA and adding Sample and Type as a supplimental qualitative variable
PCA = PCA(Data_sources[c(variables,tracers_mixing)], scale.unit = FALSE, quali.sup = variables, graph = FALSE)

# ## Uncomment these lines to see some diagnostics of how the PCA ran
# # Plot component variance
# fviz_eig(PCA, addlabels = FALSE, geom = "bar")
# 
# # Print a summary of the PCA results
# summary(PCA)

# Plot PC1&2 results and project variable vectors and print
fviz_pca_biplot(PCA, axes = c(1,2), # axes tell which components to plot
                geom = "point", addEllipses = TRUE, col.ind = Data_sources[[Source_Variable]], col.var = 'grey50', repel=TRUE, # some display settings
                label = c("quali", "var")) # labelling
```

We'll also try fitting an LDA to see if this is can work as a better tool to visualize our mixing space.

```{r LDA_sources, dpi=300, fig.asp=0.8}
ntypes = nlevels(as.factor(Data_sources[[Source_Variable]]))
# fitting the model with leave one out cross validation
LDA.test = lda(Group ~ . ,data = Data_sources[c(Source_Variable,tracers_mixing)], CV = TRUE,
               prior = rep(1/ntypes, ntypes))

# ## uncomment these lines to see the results of leave one out cross-validation 
# ## and see some LDA model diagnostics
# print model result
# LDA.train

# # create a table which compares the classification of the LDA model to the actual producer type
# ct.prod.norm <- table(Data_sources[[Source_Variable]], 
#                       LDA.test$class)
# # total percent of samples correctly classified is the sum of the diagonal of this table
# noquote(c('% successfully categorized: ', sum(diag(prop.table(ct.prod.norm))))) #85% effective

# Refitting the model using all of the available training data
LDA.full = lda(Group ~ . ,data = Data_sources[c(Source_Variable,tracers_mixing)], CV = FALSE, prior = rep(1/ntypes, ntypes))

# ## uncomment this line to see a summary of the full LDA
# LDA.full

# store locations of training data in LD space for later plotting
pred.train = predict(LDA.full, Data_sources[tracers_mixing])
class.train = data.frame('Type' = Data_sources[[Source_Variable]], pred.train$x)

# Generate biplot with training data only
plot.mix.LD12 = ggplot(data = class.train, 
                       aes(x = LD2, y = LD1, color = Type), size = 2) + 
  geom_point(alpha = 0.3, size=3) + 
  stat_ellipse(type = 't', alpha = 0.6)+
  theme(legend.position = 'none')
plot.mix.LD13 = ggplot(data = class.train, 
                       aes(x = LD3, y = LD1, color = Type), size = 2) + 
  geom_point(alpha = 0.3, size=3) +  
  stat_ellipse(type = 't', alpha = 0.6)+
  labs(color = "Training Data")
grid.arrange(ncol = 2, widths = c(1,1.2), plot.mix.LD12, plot.mix.LD13, top = 'LDA of Organic Matter Sources') + theme(legend.position = 'top')
```

```{r LDA_sources_3D, eval=TRUE, fig.asp=0.6, out.width="100%"}
# We'll also try and put LD1, 2, and 3 on 3D axes
plot_ly(data=class.train, x=~LD1, y=~LD2, z=~LD3,
        type="scatter3d", mode="markers", color=class.train$Type,
        marker = list(line = list(color = "1", width = 0.5)))
```

# Selecting zooplankton data {-}

```{r ImportZoops, eval=TRUE, fig.asp=0.6, out.width="100%", fig.cap=c("Ternary diagram showing the fractional contribution of our three sources (small, large, and surface particles) to the base of our simulated zooplankton food web.", "Simulated samples of source material and now zooplankton are plotted with respect to all three tracer $\\dN$ values.", "Simulated samples of source material and now zooplankton are plotted with respect to $\\dNglx$ and $\\dNthr$, both normalized to $\\dNphe$.")}

## Create data frame with only the d15N values we're interested in
Data_zoops <- Data_all[c(variables,tracers[which(tracers!="d13CEAA")],SDtracers[which(SDtracers!="SDd13CEAA")])]
Data_zoops <- subset(Data_zoops,
                             (((Depth < 100 | Depth > 200)&
                                (Type == "Zooplankton" & Event == "Night")) &
                                d15NPhe >= min(Data_sources$d15NPhe) &
                                d15NLys >= min(Data_sources$d15NLys)))
Data_zoops <- na.omit(Data_zoops)
# Defining the preferred order in which to reference zooplankton sizes
# Data_zoops$Size <- factor(Data_zoops$Size, levels = c("0.2-0.5 mm","0.5-1.0 mm","1-2 mm","2-5 mm",">5 mm"))
```

We will also mean normalize essential amino acid $\dC$ data and store the mean essential amino acid $\dC$ value, if indicated above.

```{r mean_normalization_zoops}
# If mean normalizing EAA δ13C data
if(include_d13C == TRUE & meannorm_d13C == TRUE) {
  # Calculating the mean EAA δ13C value of each sample
  MN <- rowMeans(Data_zoops[tracers_d13C[which(tracers_d13C!="d13CEAA")]])
  SD <- c()
  for (i in 1:nrow(Data_zoops)) {
    SD <- append(SD, SDmean(Data_zoops[i,SDtracers_d13C[which(SDtracers_d13C!="SDd13CEAA")]]))
  }
  # Subtracting that from the EAA δ13C values for each sample
  # and replacing raw δ13C values in main data frame with mean normalized ones
  Data_zoops[tracers_d13C[which(tracers_d13C!="d13CEAA")]] <- sweep(Data_zoops[tracers_d13C[which(tracers_d13C!="d13CEAA")]], 1, MN, "-")
  # Including the mean δ13C values as an additional tracer
  Data_zoops$d13CEAA <- MN
  Data_zoops$SDd13CEAA <- SD
}
```

Let's plot out the $\dN$ values of each amino acid for the sources, theoretical food web base, and simulated zooplankton.

```{r AA_realzoops_plots, dpi=300, fig.asp=0.4, fig.width=8.5}
if (include_d13C == TRUE) {
  sources.dC.long <- 
    melt(Data_sources, id.vars=c(variables), measure.vars = tracers_d13C,
         variable.name="AA")
  sources.dC.long$AA <- sub('....','',sources.dC.long$AA)
  sources.dC.long$Isotope <- "d13C"
  zoops.dC.long <- 
    melt(Data_zoops, id.vars=c(variables), measure.vars = tracers_d13C,
         variable.name="AA")
  zoops.dC.long$AA <- sub('....','',zoops.dC.long$AA)
  zoops.dC.long$Isotope <- "d13C"
  sources.long <- sources.dC.long
  zoops.long <- zoops.dC.long
  # base.dC.long <- 
  #   melt(base.sim, id.vars=c(variables), measure.vars = tracers_d13C,
  #        variable.name="AA")
  # base.dC.long$AA <- sub('....','',base.dC.long$AA)
  # base.dC.long$Isotope <- "d13C"
  # if (include_d15N == FALSE) {
  #   sources.long <- sources.dC.long
  #   zoops.long <- zoops.dC.long
  #   base.long <- base.dC.long
  # }
}
if (include_d15N == TRUE) {
  sources.dN.long <- 
    melt(Data_sources, id.vars=c(variables), measure.vars = tracers_d15N,
         variable.name="AA")
  sources.dN.long$AA <- sub('....','',sources.dN.long$AA)
  sources.dN.long$Isotope <- "d15N"
  zoops.dN.long <- 
    melt(Data_zoops, id.vars=c(variables), measure.vars = tracers_d15N,
         variable.name="AA")
  zoops.dN.long$AA <- sub('....','',zoops.dN.long$AA)
  zoops.dN.long$Isotope <- "d15N"
  sources.long <- sources.dN.long
  zoops.long <- zoops.dN.long
  # base.dN.long <- 
  #   melt(base.sim, id.vars=c(variables), measure.vars = tracers_d15N,
  #        variable.name="AA")
  # base.dN.long$AA <- sub('....','',base.dN.long$AA)
  # base.dN.long$Isotope <- "d15N"
  # if (include_d13C == FALSE) {
  #   sources.long <- sources.dN.long
  #   zoops.long <- zoops.dN.long
  #   base.long <- base.dN.long
  # }
}
if (include_d13C == include_d15N) {
  sources.long <- rbind(sources.dN.long,sources.dC.long)
  zoops.long <- rbind(zoops.dN.long,zoops.dC.long)
  # base.long <- rbind(base.dN.long,base.dC.long)
}
sources.long$AA <- factor(sources.long$AA, levels = allAA)
zoops.long$AA <- factor(zoops.long$AA, levels = allAA)


AA_plots <-
  ggplot(sources.long)+
  geom_point(aes(x = AA, y = value, color = Group), alpha=0.4,
             position = position_nudge(x = 0.1))+
  geom_point(data = zoops.long,
             aes(x = AA, y = value, shape=Size),
             position = position_nudge(x = -0.1))+
  # geom_point(data = base.long,
  #            aes(x = AA, y = value, shape="posterior mean"), color = "brown", alpha=1,
  #            position = position_dodge2(width = 0.2))+
  ylab(expression(delta^{15}*N*" (\u2030)"))+
  labs(color="Organic Matter Source", shape="Zooplankton Samples")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.3, hjust=1))+
  facet_row(~Isotope, scales="free", space="free")
AA_plots
```

In order to better visualize the data we've generated in multivariate space we'll fit an LDA to the source data and then plot the simulated base of the food web and zooplankton in the LD space. We will also fit a PCA to visualize source separation and amino acid loadings.

```{r LDA_realzoops, dpi=300, fig.asp=0.8}

# poject zooplankton into LD space and predict classification
pred.zoops = predict(LDA.full, Data_zoops)
#class.zoops = data.frame('Class' = pred.zoops$class, pred.zoops$x)
# generate data frame which stores predicted classification of particles indexed by size and depth
class.zoops = data.frame('Predicted' = pred.zoops$class, pred.zoops$x, lapply(Data_zoops[,variables], as.character))
# Predicted probabilities of class membership
head(pred.zoops$posterior,n=dim(pred.zoops$posterior))
# linear discriminants
head(pred.zoops$x,n=dim(pred.zoops$x))

# # poject food web base into LD space and predict classification
# pred.base = predict(LDA.full, base.sim)
# # generate data frame which stores predicted classification of particles indexed by size and depth
# class.base = data.frame('Predicted' = pred.base$class, pred.base$x, lapply(Data_zoops[,variables], as.character))
# # # Predicted probabilities of class membership
# # head(pred.base$posterior,n=dim(pred.base$posterior))
# # # linear discriminants
# # head(pred.base$x,n=dim(pred.base$x))

# Generate biplot with Zooplankton overlayed onto training data
plot.mix.LD12 = ggplot(data = class.train, 
                       aes(x = LD2, y = LD1, color = Type), size = 2) + 
  geom_point(alpha = 0.3) + 
  stat_ellipse(type = 't', alpha = 0.6)+
  geom_point(data = class.zoops,
             aes(x = LD2, y = LD1, shape = Size),color = 'black')+
  # geom_point(data = class.base,
  #            aes(x = LD2, y = LD1, shape = "Food Web Base"),color = 'red')+
  # geom_text(data = class.zoops,
            # aes(label=Depth),hjust=-0.2, vjust=1.1)+
  # coord_cartesian(xlim=c(-5,5), ylim=c(-7.5,5)) + 
  theme(legend.position = 'none')
plot.mix.LD13 = ggplot(data = class.train, 
                       aes(x = LD3, y = LD1, color = Type), size = 2) + 
  geom_point(alpha = 0.3) +  
  stat_ellipse(type = 't', alpha = 0.6)+
  geom_point(data = class.zoops,
             aes(x = LD3, y = LD1, shape = Size),color = 'black')+
  # geom_point(data = class.base,
  #            aes(x = LD3, y = LD1, shape = "Food Web Base"),color = 'red')+
  # geom_point(data = class.zoops, 
  #            aes(x = LD3, y = LD1, shape = Predicted), color = 'black')+
  # geom_text(data = class.zoops,
            # aes(label=Depth),hjust=-0.2, vjust=1.1)+
  # coord_cartesian(xlim=c(-5,5), ylim=c(-7.5,5)) + 
  labs(shape = "Zooplankton Samples") + labs(color = "Organic Matter Sources")
grid.arrange(ncol = 2, widths = c(1,1.6), plot.mix.LD12, plot.mix.LD13, top = 'LDA of Organic Matter Sources') + theme(legend.position = 'top')
```

Okay! So we've got our tracer data for organic matter sources imported, we've simulated some zooplankton using known ecological parameters, and we've visualized the relationships between source groups, the base of the food web, and our zooplankton.

# Solving food web model using MCMC {-}
Next, we will use Markov Chain Monte Carlo to find PDFs describing the most likely solutions to our mixing problem. First we will write a BUGS model, then use JAGS to do the MCMC. For the first model run we will use a vague prior, incorporating the full range of possible uncertainty in TDFs and $\dNAA$/$\dCAA$ values
## Drafting a BUGS model {-}
First we will write up our BUGS model.

```{r FWM_2, eval=TRUE}
if(include_d13C == TRUE & include_d15N == TRUE){
FWM_2 <- "model {
/* observe tracers in sources */
  # Each row will be a sample
  # Each column will be a tracer
    
  # Surface Particles - A
  for (i in 1:N_A) { # Loop though all samples of this type
    for (j in 1:N_T) { # Loop through all tracers of for each sample
      X_A[i,j] ~ dnorm(mean_A[j], 1/sd_A[j]^2)
    }
  }
  
  # Large Particles - L
  for (i in 1:N_B) { # Loop though all samples of this type
    for (j in 1:N_T) { # Loop through all tracers of for each sample
      X_B[i,j] ~ dnorm(mean_B[j], 1/sd_B[j]^2)
    }
  }
  
  # Small Particles - S
  for (i in 1:N_C) { # Loop though all samples of this type
    for (j in 1:N_T) { # Loop through all tracers of for each sample
      X_C[i,j] ~ dnorm(mean_C[j], 1/sd_C[j]^2)
    }
  }
  
  # Submicron Particles - M
  for (i in 1:N_D) { # Loop though all samples of this type
    for (j in 1:N_T) { # Loop through all tracers of for each sample
      X_D[i,j] ~ dnorm(mean_D[j], 1/sd_D[j]^2)
    }
  }
  
  /* uniform priors for tracer means in prey/sources */
  for (j in 1:N_T) {
    mean_A[j] ~ dunif(-100,100)
    mean_B[j] ~ dunif(-100,100)
    mean_C[j] ~ dunif(-100,100)
    mean_D[j] ~ dunif(-100,100)
  }
  /* approximate reciprocal priors for tracer sd in prey/sources */
  for (j in 1:N_T) {
    sd_A[j] ~ dgamma(0.001, 0.001) T(,3)
    sd_B[j] ~ dgamma(0.001, 0.001) T(,2)
    sd_C[j] ~ dgamma(0.001, 0.001) T(,2)
    sd_D[j] ~ dgamma(0.001, 0.001) T(,2)
  }
  
  /* priors for TDFs */
  # metazoan TDFs
  for (j in i_T_frac) {
    TDF_meta[j] ~ dnorm(TDF_m[j] , 1/sdTDF_m[j]^2)
  }
  # protozoan TDFs
  for (j in i_T_frac) {
    TDF_proto[j] ~ dnorm(TDF_p[j] , 1/sdTDF_p[j]^2)
  }
  
  /* priors for the zooplankton z_k */
    for (iz in 1:N_Z) { # N_Z is the number of zooplankton
      pz[iz, 1:4] ~ ddirch(c(1,1,1,1)) # uniform priors
      MTS[iz] ~ dunif(0,10) # prior for food web length
      sdMTS[iz] ~ dgamma(0.001, 0.001) # and its uncertainty
      PTS[iz] ~  dunif(-1,10) # prior for protistan trophic steps
      sdPTS[iz] ~ dgamma(0.001, 0.001) # and its uncertainty
    }
    
  /* calculate tracers at the base of the food web and then in zooplankton */
    for (iz in 1:N_Z) {
      
      ## Carrying out organic matter source mixing at the base of the food web
      for (j in 1:N_T) {
        mean_b[iz,j] <- pz[iz,1]*mean_A[j] + pz[iz,2]*mean_B[j] + pz[iz,3]*mean_C[j] + pz[iz,4]*mean_D[j]
      }
      
      ## Carrying out trophic enrichment from food web base to zooplankton
      ## calculating FWL from MTS and PTS
      FWL[iz] <- MTS[iz] + PTS[iz]
      ## Non-fractionating AAs
      for (j in i_T_non) {
        mean_z[iz,j] <- mean_b[iz, j]
      }
      ## AAs with constant TDFs
      for (j in i_T_const) {
        mean_z[iz,j]  <- mean_b[iz, j]  + FWL[iz]*TDF_meta[j]
      }
      ## AAs with variable TDFs
      for (j in i_T_var) {
        mean_z[iz,j]  <- mean_b[iz, j]  + PTS[iz]*TDF_proto[j] + MTS[iz]*TDF_meta[j]
      }
      
      ## tracer observations
      for (j in i_T_mix) {
        Y[iz,j] ~ dnorm(mean_z[iz,j] , 1/sd_Y[iz,j]^2)
      }
    }
}"}

if(include_d13C == FALSE & include_d15N == TRUE){
FWM_2 <- "model {
/* observe tracers in sources */
  # Each row will be a sample
  # Each column will be a tracer
    
  # Surface Particles - A
  for (i in 1:N_A) { # Loop though all samples of this type
    for (j in 1:N_T) { # Loop through all tracers for each sample
      X_A[i,j] ~ dnorm(mean_A[j], 1/sd_A[j]^2)
    }
  }
  
  # Large Particles - L
  for (i in 1:N_B) { # Loop though all samples of this type
    for (j in 1:N_T) { # Loop through all tracers for each sample
      X_B[i,j] ~ dnorm(mean_B[j], 1/sd_B[j]^2)
    }
  }
  
  # Small Particles - S
  for (i in 1:N_C) { # Loop though all samples of this type
    for (j in 1:N_T) { # Loop through all tracers for each sample
      X_C[i,j] ~ dnorm(mean_C[j], 1/sd_C[j]^2)
    }
  }
  
  # Submicron Particles - M
  for (i in 1:N_D) { # Loop though all samples of this type
    for (j in 1:N_T) { # Loop through all tracers for each sample
      X_D[i,j] ~ dnorm(mean_D[j], 1/sd_D[j]^2)
    }
  }
  
  /* uniform priors for tracer means in prey/sources */
  for (j in 1:N_T) {
    mean_A[j] ~ dunif(-100,100)
    mean_B[j] ~ dunif(-100,100)
    mean_C[j] ~ dunif(-100,100)
    mean_D[j] ~ dunif(-100,100)
  }
  /* approximate reciprocal priors for tracer sd in prey/sources */
  for (j in 1:N_T) {
    sd_A[j] ~ dgamma(0.001, 0.001) T(,2)
    sd_B[j] ~ dgamma(0.001, 0.001) T(,2)
    sd_C[j] ~ dgamma(0.001, 0.001) T(,2)
    sd_D[j] ~ dgamma(0.001, 0.001) T(,2)
  }
  
  /* priors for TDFs */
  # metazoan TDFs
  for (j in i_T_frac) {
    TDF_meta[j] ~ dnorm(TDF_m[j] , 1/sdTDF_m[j]^2)
  }
  # protozoan TDFs
  for (j in i_T_frac) {
    TDF_proto[j] ~ dnorm(TDF_p[j] , 1/sdTDF_p[j]^2)
  }
  
  /* priors for the zooplankton */
    for (iz in 1:N_Z) { # N_Z is the number of zooplankton
      pz[iz, 1:4] ~ ddirch(c(1,1,1,1)) # uniform priors
      MTS[iz] ~ dunif(0,10) # prior for food web length 
      sdMTS[iz] ~ dgamma(0.001, 0.001) # and its uncertainty
      PTS[iz] ~  dunif(-1,10) # prior for protistan trophic steps
      sdPTS[iz] ~ dgamma(0.001, 0.001) # and its uncertainty
    }
    
  /* calculate tracers at the base of the food web and then in zooplankton */
    for (iz in 1:N_Z) {
      
      ## Carrying out organic matter source mixing at the base of the food web
      for (j in 1:N_T) {
        mean_b[iz,j] <- pz[iz,1]*mean_A[j] + pz[iz,2]*mean_B[j] + pz[iz,3]*mean_C[j] + pz[iz,4]*mean_D[j]
      }
      
      ## Carrying out trophic enrichment from food web base to zooplankton
      ## calculating FWL from MTS and PTS
      FWL[iz] <- MTS[iz] + PTS[iz]
      # ## Non-fractionating AAs
      # for (j in i_T_non) {
      #   mean_z[iz,j] <- mean_b[iz, j]
      # }
      ## AAs with constant TDFs
      for (j in i_T_const) {
        mean_z[iz,j]  <- mean_b[iz, j] + FWL[iz]*TDF_meta[j]
      }
      ## AAs with variable TDFs
      for (j in i_T_var) {
        mean_z[iz,j]  <- mean_b[iz, j]  + PTS[iz]*TDF_proto[j] + MTS[iz]*TDF_meta[j]
      }
      
      ## tracer observations
      for (j in i_T_mix) {
        Y[iz,j] ~ dnorm(mean_z[iz,j] , 1/(sd_Y[iz,j])^2)
      }
    }
}"}
```

## Setting up for MCMC {-}

Organizing the input data for MCMC.
```{r datalist, eval=TRUE}

N_T <- length(tracers) # number of tracers
N_S <- length(Sources)
N_Z <- nrow(Data_zoops) # number of zooplankton samples
sd.anl <- 0.52
sdTDF_scaling_factor <- 0.2
sdY_scaling_factor <- 2

data_1 <- list(
  ## How many tracers will be used in this model?
  N_T = N_T,
  ## How many zooplankton samples are there?
  N_Z = N_Z,
  ## Where should the model look for zooplankton amino acid isotope data?
  Y   = as.matrix(Data_zoops[tracers]),
  ## and the analytical uncertainty in those measurements
  sd_Y = as.matrix(Data_zoops[SDtracers])*sdY_scaling_factor,
  ## Which tracers do not fractionate?
  i_T_non = which(tracers %in% tracers_d13C),
  ## Which tracers do fractionate?
  i_T_frac = which(tracers %in% tracers_d15N),
  ## Which tracers have constant TDFs throughout the food web?
  i_T_const = which(tracers %in% tracers_constTDF),
  ## Which tracers have variable TDFs throughout the food web?
  i_T_var = which(tracers %in% tracers_varTDF),
  ## Which tracers will be used in the mixing model and see the data?
  i_T_mix = which(tracers %in% tracers_mixing),
  ## Where should the model look for TDF data and its associated uncertainty?
  # for metazoan TDFs
  TDF_m   = as.numeric(TDF_meta[tracers_d15N]),
  sdTDF_m = as.numeric(TDF_meta[SDtracers_d15N])*sdTDF_scaling_factor,
  # for protozoan TDFs
  TDF_p   = as.numeric(TDF_proto[tracers_d15N]),
  sdTDF_p = as.numeric(TDF_proto[SDtracers_d15N])*sdTDF_scaling_factor
  )

## Where should the model look for organic matter source data?
## making generalized names A-F for a max of six possible organic matter sources
sources_alpha <- c("X_A","X_B","X_C","X_D","X_E","X_F")
SDsources_alpha <- c("sdX_A","sdX_B","sdX_C","sdX_D","sdX_E","sdX_F")
nsams_alpha   <- c("N_A","N_B","N_C","N_D","N_E","N_F")
## Loop through all sources described in setup chunks above to add that data
## to the data_1 list as individual matrices for each source
for (i in 1:N_S) {
  sams_source <- Data_sources[Data_sources[[Source_Variable]]==Sources[i],c(tracers,SDtracers)]
  data_1[[sources_alpha[i]]] = as.matrix(sams_source[tracers])
  data_1[[SDsources_alpha[i]]] = as.double(colMeans(sams_source[SDtracers]))
  data_1[[nsams_alpha[i]]]   = sum((Data_sources[[Source_Variable]]==Sources[i])*1)
}

if(length(data_1$i_T_non)==0){
  data_1$i_T_non <- 0
}
if(length(data_1$i_T_frac)==0){
  data_1$i_T_frac <- 0
}
if(length(data_1$i_T_const)==0){
  data_1$i_T_const <- 0
}
if(length(data_1$i_T_var)==0){
  data_1$i_T_var <- 0
}
```
and defining our initial values.
```{r initlist, eval=TRUE}
set.seed(123)
Nchains <- 3
inits_1 <- vector(mode="list", length=Nchains) # initial values
means_alpha <- c("mean_A","mean_B","mean_C","mean_D","mean_E","mean_F")
sd_alpha <- c("sd_A","sd_B","sd_C","sd_D","sd_E","sd_F")
fun_init_1 <- function(i) {
  inits <- 
    list(TDF_meta = runif(length(TDF_meta[tracers_d15N]),
                          as.double(TDF_meta[tracers_d15N]-TDF_meta[SDtracers_d15N]),
                          as.double(TDF_meta[tracers_d15N]+TDF_meta[SDtracers_d15N])),
         TDF_proto = runif(length(TDF_proto[tracers_d15N]), 
                           as.double(TDF_proto[tracers_d15N]-TDF_proto[SDtracers_d15N]), 
                           as.double(TDF_proto[tracers_d15N]+TDF_proto[SDtracers_d15N])), 
         # runif(length(tracers_d15N), 0, 20),
         pz        = rdirichlet(n=N_Z, c(1,1,1,1)),
         PTS       = runif(n=N_Z, 0, 5),
         sdPTS    = rtgamma(n=N_Z, 0.001, 0.001, 10^-50),
         MTS   = runif(n=N_Z, 0, 5),
         sdMTS = rtgamma(n=N_Z, 0.001, 0.001, 10^-50),
         .RNG.seed = i+1,
         .RNG.name = c("base::Super-Duper", 
                       "base::Wichmann-Hill",
                       "base::Marsaglia-Multicarry")[i %% 3 + 1]
    )
  # if (sum(tracers=="d15NThr")>0) {
  #   inits$TDF_meta[which(tracers=="d15NThr")] = runif(1, 
  #                         as.double(TDF_meta["d15NThr"]-TDF_meta["SDd15NThr"]), 
  #                         as.double(TDF_meta["d15NThr"]+TDF_meta["SDd15NThr"]))
  #   # runif(1, -20, 0)
  #   inits$TDF_proto[which(tracers=="d15NThr")] = runif(1, 
  #                          as.double(TDF_proto["d15NThr"]-TDF_proto["SDd15NThr"]), 
  #                          as.double(TDF_proto["d15NThr"]+TDF_proto["SDd15NThr"]))
  #   # runif(1, -20, 0)
  # }
  for (j in 1:N_S) {
    inits[[means_alpha[j]]] = runif(N_T, -40, 20)
    inits[[sd_alpha[j]]] = runif(N_T, 0, 2)
  }
  return(inits)
}
for (i in 1:Nchains) inits_1[[i]] <- fun_init_1(i)
```

## Running MCMC in JAGS {-}
Now we can run the MCMC!

```{r runjags, eval=TRUE}
samsPerChain <- 10000 # needed  below for narrative, so we give it a name.
monitor_vars = c("mean_A", "sd_A",
                 "mean_B", "sd_B",
                 "mean_C", "sd_C",
                 "mean_D", "sd_D",
                 "mean_b", "mean_z",
                 "TDF_meta", "sdTDF_m",
                 "TDF_proto","sdTDF_p",
                 "pz"       , "FWL"  , "PTS", "MTS")

rjo_1 <- # S3 object of class "runjags"
  run.jags(model = FWM_2,
           data = data_1,
           inits = inits_1,
           silent.jags = FALSE,
           n.chains = Nchains,
           adapt  = 20000,
           burnin = 20000,
           thin = 10,
           sample = samsPerChain,
           method = "parallel",
           modules = "glm",
           monitor = monitor_vars
          )
```

## Diagnostics {-} 
Here we run some diagnostics. Initially we use John K. Kruschke's function `diagMCMC` to check out model parameters and make sure things are running properly. When these diagnostics look good, we set `eval=FALSE` in the chunk header and made a nicer parameter plot comparing known parameter values and the MCMC posteriors for those parameters, which is seen below.

```{r diagMu, eval=TRUE, fig.cap="Means of tracers 1 and 2 for prey types A,B,C."}
## Kruschke's utility functions (edited by NF)
if (c(TRUE,FALSE)[1]) source("DBDA2E-utilities.R") 
diagMCMC(rjo_1$mcmc, parName="FWL[1]")
diagMCMC(rjo_1$mcmc, parName="MTS[1]")
diagMCMC(rjo_1$mcmc, parName="PTS[1]")
diagMCMC(rjo_1$mcmc, parName="pz[1,1]")
diagMCMC(rjo_1$mcmc, parName="pz[1,2]")
diagMCMC(rjo_1$mcmc, parName="pz[1,3]")
diagMCMC(rjo_1$mcmc, parName="pz[1,4]")
diagMCMC(rjo_1$mcmc, parName="mean_z[1,9]")

# diagMCMC(rjo_1$mcmc, parName="TDF_meta[1]")
# diagMCMC(rjo_1$mcmc, parName="TDF_meta[3]")
# diagMCMC(rjo_1$mcmc, parName="TDF_meta[10]")
# diagMCMC(rjo_1$mcmc, parName="TDF_proto[1]")
# diagMCMC(rjo_1$mcmc, parName="TDF_proto[3]")
# diagMCMC(rjo_1$mcmc, parName="TDF_proto[10]")
# diagMCMC(rjo_1$mcmc, parName="sdTDF_meta[1]")
# diagMCMC(rjo_1$mcmc, parName="sdTDF_meta[3]")
# diagMCMC(rjo_1$mcmc, parName="sdTDF_meta[10]")
# diagMCMC(rjo_1$mcmc, parName="mean_A[10]")
# diagMCMC(rjo_1$mcmc, parName="mean_B[10]")
# diagMCMC(rjo_1$mcmc, parName="mean_C[10]")
# diagMCMC(rjo_1$mcmc, parName="mean_D[10]")
# diagMCMC(rjo_1$mcmc, parName="sd_A[10]")
# diagMCMC(rjo_1$mcmc, parName="sd_B[10]")
# diagMCMC(rjo_1$mcmc, parName="sd_C[10]")
# diagMCMC(rjo_1$mcmc, parName="sd_D[10]")
```  

# Visualizing Results {-}
Now let's generate some data structures to store the MCMC output and other relevant data from generating plots and figures. There are a few different data types we need to get out of the MCMC output

  1. Global model parameter posteriors (TDFs, d15N(sources), SDd15N(tracers))
  2. Zooplankton food web parameter posteriors (mixing coefficients, trophic positions, and d15N values at the base of the food web)

We'll look at these one at a time.

## MCMC global parameter posteriors {-}

```{r MCMC_global_param_extraction}
## Grabbing MCMC model output
sams <- as.matrix(rjo_1$mcmc)
nsams <- nrow(sams)
nsources <- length(Sources)
nzoops <- nrow(Data_zoops)
ntracers <- length(tracers)
ntracers_candv <- length(tracers_candv)
ntracers_varTDF <- length(tracers_varTDF)

## 1. Global model parameter posteriors (TDFs, d15N(sources)) ##
# we'll make a list which contains samples and summary data for each set of posteriors
posts.global <- list(
  TDF_meta = list(
    samples = data.frame(matrix(nrow = nsams,ncol=0)),
    HDI95 = data.frame(matrix(nrow = 2,ncol=0)),
    HDI90 = data.frame(matrix(nrow = 2,ncol=0)),
    HDI75 = data.frame(matrix(nrow = 2,ncol=0)),
    HDI50 = data.frame(matrix(nrow = 2,ncol=0)),
    mean = data.frame(matrix(nrow = 1,ncol=0)),
    mode = data.frame(matrix(nrow = 1,ncol=0))
  ),
  TDF_proto = list(
    samples = data.frame(matrix(nrow = nsams,ncol=0)),
    HDI95 = data.frame(matrix(nrow = 2,ncol=0)),
    HDI90 = data.frame(matrix(nrow = 2,ncol=0)),
    HDI75 = data.frame(matrix(nrow = 2,ncol=0)),
    HDI50 = data.frame(matrix(nrow = 2,ncol=0)),
    mean = data.frame(matrix(nrow = 1,ncol=0)),
    mode = data.frame(matrix(nrow = 1,ncol=0))
  ),
  mean_Sources = list(
    samples = data.frame(matrix(nrow = nsams*nsources,ncol=0)),
    HDI95 = data.frame(matrix(nrow = 2*nsources,ncol=0)),
    HDI90 = data.frame(matrix(nrow = 2*nsources,ncol=0)),
    HDI75 = data.frame(matrix(nrow = 2*nsources,ncol=0)),
    HDI50 = data.frame(matrix(nrow = 2*nsources,ncol=0)),
    mean = data.frame(matrix(nrow = 1*nsources,ncol=0)),
    mode = data.frame(matrix(nrow = 1*nsources,ncol=0))
  )
)

# grabbing TDF posteriors
for (i in which(tracers %in% tracers_candv)) {
  # samples of TDF_meta
  posts.global$TDF_meta$samples[,tracers[i]] <- 
    sams[,paste("TDF_meta[",i,"]",sep = "")]
  # HDI min and max of TDF_meta
  posts.global$TDF_meta$HDI95[,tracers[i]] <- 
    HDIofMCMC(sams[,paste("TDF_meta[",i,"]",sep = "")], credMass=0.95)
  posts.global$TDF_meta$HDI90[,tracers[i]] <- 
    HDIofMCMC(sams[,paste("TDF_meta[",i,"]",sep = "")], credMass=0.90)
  posts.global$TDF_meta$HDI75[,tracers[i]] <- 
    HDIofMCMC(sams[,paste("TDF_meta[",i,"]",sep = "")], credMass=0.75)
  posts.global$TDF_meta$HDI50[,tracers[i]] <- 
    HDIofMCMC(sams[,paste("TDF_meta[",i,"]",sep = "")], credMass=0.50)
  # mean of TDF_meta
  posts.global$TDF_meta$mean[,tracers[i]] <- 
    mean(sams[,paste("TDF_meta[",i,"]",sep = "")])
  # mean of TDF_meta
  posts.global$TDF_meta$mode[,tracers[i]] <- 
    post.mode(sams[,paste("TDF_meta[",i,"]",sep = "")])
}
for (i in which(tracers %in% tracers_varTDF)) {
  # samples of TDF proto
  posts.global$TDF_proto$samples[tracers[i]] <- 
    sams[,paste("TDF_proto[",i,"]",sep = "")]
  # HDI min and max of TDF_proto
  posts.global$TDF_proto$HDI95[tracers[i]] <- 
    HDIofMCMC(sams[,paste("TDF_proto[",i,"]",sep = "")], credMass = 0.95)
  posts.global$TDF_proto$HDI90[tracers[i]] <- 
    HDIofMCMC(sams[,paste("TDF_proto[",i,"]",sep = "")], credMass = 0.90)
  posts.global$TDF_proto$HDI75[tracers[i]] <- 
    HDIofMCMC(sams[,paste("TDF_proto[",i,"]",sep = "")], credMass = 0.75)
  posts.global$TDF_proto$HDI50[tracers[i]] <- 
    HDIofMCMC(sams[,paste("TDF_proto[",i,"]",sep = "")], credMass = 0.50)
  # mean of TDF_proto
  posts.global$TDF_proto$mean[tracers[i]] <- 
    mean(sams[,paste("TDF_proto[",i,"]",sep = "")])
  # mean of TDF_proto
  posts.global$TDF_proto$mode[tracers[i]] <- 
    post.mode(sams[,paste("TDF_proto[",i,"]",sep = "")])
}
# grabbing d15N(source) posteriors
source_alpha <- c("A","B","C","D","E","F")
temp1<-temp2<-temp3<-c()
# 1st column tells which source
for (j in 1:length(Sources)) {
  temp1 <- c(temp1, rep(Sources[j],nsams))
  temp2 <- c(temp2, rep(Sources[j],2))
  temp3 <- c(temp3, Sources[j])
}
posts.global$mean_Sources$samples$Group <- temp1
posts.global$mean_Sources$HDI95$Group <-
  posts.global$mean_Sources$HDI90$Group <-
  posts.global$mean_Sources$HDI75$Group <-
  posts.global$mean_Sources$HDI50$Group <- temp2
posts.global$mean_Sources$mean$Group <-
  posts.global$mean_Sources$mode$Group <-temp3
# next columns give respective d15N data
for (i in 1:length(tracers)) {
  temp1<-temp2<-temp3<-temp4<-temp5<-temp6<-temp7<-c()
  for (j in 1:length(Sources)) {
    temp1 <- c(temp1, sams[,paste("mean_",source_alpha[j],"[",i,"]",sep = "")])
    temp2 <- 
      c(temp2, HDIofMCMC(sams[,paste("mean_",source_alpha[j],"[",i,"]",sep = "")], credMass=0.95))
    temp3 <- 
      c(temp3, HDIofMCMC(sams[,paste("mean_",source_alpha[j],"[",i,"]",sep = "")], credMass=0.90))
    temp4 <- 
      c(temp4, HDIofMCMC(sams[,paste("mean_",source_alpha[j],"[",i,"]",sep = "")], credMass=0.75))
    temp5 <- 
      c(temp5, HDIofMCMC(sams[,paste("mean_",source_alpha[j],"[",i,"]",sep = "")], credMass=0.50))
    temp6 <- c(temp6, mean(sams[,paste("mean_",source_alpha[j],"[",i,"]",sep = "")]))
    temp7 <- c(temp7, post.mode(sams[,paste("mean_",source_alpha[j],"[",i,"]",sep = "")]))
  }
  posts.global$mean_Sources$samples[tracers[i]] <- temp1
  posts.global$mean_Sources$HDI95[tracers[i]] <- temp2
  posts.global$mean_Sources$HDI90[tracers[i]] <- temp3
  posts.global$mean_Sources$HDI75[tracers[i]] <- temp4
  posts.global$mean_Sources$HDI50[tracers[i]] <- temp5
  posts.global$mean_Sources$mean[tracers[i]] <- temp6
  posts.global$mean_Sources$mode[tracers[i]] <- temp7
}

# at times we'll want this data in long format so we'll handle that here as well
posts.global.long <- list(
  TDF_meta = list(
    samples = melt(posts.global$TDF_meta$samples, value.name = "d15N", variable.name = "AA"),
    HDI95 = melt(posts.global$TDF_meta$HDI95, value.name = "d15N", variable.name = "AA"),
    HDI90 = melt(posts.global$TDF_meta$HDI90, value.name = "d15N", variable.name = "AA"),
    HDI75 = melt(posts.global$TDF_meta$HDI75, value.name = "d15N", variable.name = "AA"),
    HDI50 = melt(posts.global$TDF_meta$HDI50, value.name = "d15N", variable.name = "AA"),
    mean = melt(posts.global$TDF_meta$mean, value.name = "d15N", variable.name = "AA"),
    mode = melt(posts.global$TDF_meta$mode, value.name = "d15N", variable.name = "AA")
  ),
  TDF_proto = list(
    samples = melt(posts.global$TDF_proto$samples, value.name = "d15N", variable.name = "AA"),
    HDI95 = melt(posts.global$TDF_proto$HDI95, value.name = "d15N", variable.name = "AA"),
    HDI90 = melt(posts.global$TDF_proto$HDI90, value.name = "d15N", variable.name = "AA"),
    HDI75 = melt(posts.global$TDF_proto$HDI75, value.name = "d15N", variable.name = "AA"),
    HDI50 = melt(posts.global$TDF_proto$HDI50, value.name = "d15N", variable.name = "AA"),
    mean = melt(posts.global$TDF_proto$mean, value.name = "d15N", variable.name = "AA"),
    mode = melt(posts.global$TDF_proto$mode, value.name = "d15N", variable.name = "AA")
  ),
  mean_Sources = list(
    samples = melt(posts.global$mean_Sources$samples, 
                   id.vars = "Group", value.name = "d15N", variable.name = "AA"),
    HDI95 = melt(posts.global$mean_Sources$HDI95, 
                   id.vars = "Group", value.name = "d15N", variable.name = "AA"),
    HDI90 = melt(posts.global$mean_Sources$HDI90, 
                   id.vars = "Group", value.name = "d15N", variable.name = "AA"),
    HDI75 = melt(posts.global$mean_Sources$HDI75, 
                   id.vars = "Group", value.name = "d15N", variable.name = "AA"),
    HDI50 = melt(posts.global$mean_Sources$HDI50, 
                   id.vars = "Group", value.name = "d15N", variable.name = "AA"),
    mean = melt(posts.global$mean_Sources$mean, 
                   id.vars = "Group", value.name = "d15N", variable.name = "AA"),
    mode = melt(posts.global$mean_Sources$mode, 
                   id.vars = "Group", value.name = "d15N", variable.name = "AA")
  )
)

# Generate columns indicate the amino acid and if it is a d15N or d13C value
posts.global.long$mean_Sources$samples$Isotope <-
  substr(posts.global.long$mean_Sources$samples$AA, start=1, stop=4)
posts.global.long$mean_Sources$samples$AA <- 
  factor(substr(posts.global.long$mean_Sources$samples$AA, start=5, stop=7), levels = allAA)
posts.global.long$mean_Sources$HDI95$Isotope <- 
  substr(posts.global.long$mean_Sources$HDI95$AA, start=1, stop=4)
posts.global.long$mean_Sources$HDI90$Isotope <- 
  substr(posts.global.long$mean_Sources$HDI90$AA, start=1, stop=4)
posts.global.long$mean_Sources$HDI75$Isotope <- 
  substr(posts.global.long$mean_Sources$HDI75$AA, start=1, stop=4)
posts.global.long$mean_Sources$HDI50$Isotope <- 
  substr(posts.global.long$mean_Sources$HDI50$AA, start=1, stop=4)
posts.global.long$mean_Sources$HDI95$AA <- 
  factor(substr(posts.global.long$mean_Sources$HDI95$AA, start=5, stop=7), levels = allAA)
posts.global.long$mean_Sources$HDI90$AA <- 
  factor(substr(posts.global.long$mean_Sources$HDI90$AA, start=5, stop=7), levels = allAA)
posts.global.long$mean_Sources$HDI75$AA <- 
  factor(substr(posts.global.long$mean_Sources$HDI75$AA, start=5, stop=7), levels = allAA)
posts.global.long$mean_Sources$HDI50$AA <- 
  factor(substr(posts.global.long$mean_Sources$HDI50$AA, start=5, stop=7), levels = allAA)
posts.global.long$mean_Sources$mean$Isotope <- 
  substr(posts.global.long$mean_Sources$mean$AA, start=1, stop=4)
posts.global.long$mean_Sources$mean$AA <- 
  factor(substr(posts.global.long$mean_Sources$mean$AA, start=5, stop=7), levels = allAA)
posts.global.long$mean_Sources$mode$Isotope <- 
  substr(posts.global.long$mean_Sources$mode$AA, start=1, stop=4)
posts.global.long$mean_Sources$mode$AA <- 
  factor(substr(posts.global.long$mean_Sources$mode$AA, start=5, stop=7), levels = allAA)
```

Let's generate plots of the MCMC posteriors for global model parameters. Mainly here we're interested in making sure that the mean $\dNAA$ and $\dCAA$ values that the model used in mixing models agree well with the data, and looking to see what the model selected for $\DNAA$ values.

```{r global_posterior_comparisons, dpi=500, fig.asp=0.4, fig.width=8.5}
# We're going to import the literature D15N data to add to our global posterior plots for comparison
D15N_lit <- read_excel("~/University_of_Hawaii/SIA_work/EXPORTS/Data/Literature/McMahon_McCarthy_ES15-00698_Supplement1.xlsx",
    sheet = "Proto-vs-Metazoans", n_max = 21)
D15N_lit_long <- melt(D15N_lit, id.vars=c("ProMet"), measure.vars = tracers_d15N,
         variable.name="AA")

theme_set(theme_classic2()+
            theme(panel.grid.major.x = element_line(colour = "grey95"),
                  panel.grid.major.y = element_line(colour = "grey95")))

## Plotting posterior Δ15N values compared to true values

labels1 <- c('d15NGlx'="Glx",'d15NAsx'="Asx",'d15NAla'="Ala",'d15NIle'="Ile",'d15NLeu'="Leu",'d15NPro'="Pro",'d15NVal'="Val",'d15NGly'="Gly",'d15NSer'="Ser",'d15NPhe'="Phe",'d15NLys'="Lys",'d15NThr'="Thr")
labels2 <- c('d15NGlx'="Glx",'d15NAsx'="Asx",'d15NIle'="Ile",'d15NLeu'="Leu",'d15NVal'="Val")

TDF_meta.long <- melt(TDF_meta[tracers_candv], variable.name = "AA", value.name = "d15N")

plot_TDF_meta <- 
  ggplot()+
  geom_density(data = posts.global.long$TDF_meta$samples[
    which(posts.global.long$TDF_meta$samples$AA %in% tracers_candv),],
               aes(x=d15N), fill="grey90", color="grey10", size=0.5)+
  geom_line(data = posts.global.long$TDF_meta$HDI95[
    which(posts.global.long$TDF_meta$HDI95$AA %in% tracers_candv),],
            aes(x=d15N, y=rep(c(0,0),length(tracers_candv)), color=""),
            size=2,lineend="round")+
  geom_point(data=TDF_meta.long[
    which(TDF_meta.long$AA %in% tracers_candv),],
             aes(x=d15N, y=0, fill=""),
             shape=24,color="grey10",size=5, stroke=0.75)+
  geom_point(data = subset(D15N_lit_long[
    which(D15N_lit_long$AA %in% tracers_candv),], ProMet == "Metazoan"),
             aes(x=value, y=0, shape = ""))+
  scale_shape_manual(values = c(17,17))+
  ggtitle(expression(Delta^{15}*N[meta]))+
  xlab(expression(delta^{15}*N~("\u2030")))+
  facet_wrap(~AA, scales = "free", nrow = 2, labeller = as_labeller(labels1))+
  scale_x_continuous(n.breaks=4)+
  scale_color_manual(values = c("red3","steelblue"))+
  scale_fill_manual(values = c("steelblue","red3"))+
  labs(fill="True Value",color="95% HDI",shape="Literature Studies")+
  theme(axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        axis.title.y = element_blank(),plot.title = element_text(hjust = 0.5))

TDF_proto.long <- melt(TDF_proto[tracers_varTDF], variable.name = "AA", value.name = "d15N")
plot_TDF_proto <-
  ggplot()+
  geom_density(data = posts.global.long$TDF_proto$samples[
    which(posts.global.long$TDF_proto$samples$AA %in% tracers_candv),],
               aes(x=d15N), fill="grey90", color="grey10", size=0.5)+
  geom_line(data = posts.global.long$TDF_proto$HDI95,
            aes(x=d15N, y=rep(c(0,0),ntracers_varTDF), color=""),
            size=2,lineend="round")+
  geom_point(data=TDF_proto.long,
             aes(x=d15N, y=0, fill=""),
             shape=24,color="grey10",size=5, stroke=0.75)+
  geom_point(data = subset(D15N_lit_long[
    which(D15N_lit_long$AA %in% tracers_varTDF),], ProMet == "Protozoan"),
             aes(x=value, y=0, shape = ""))+
  scale_shape_manual(values = c(17,17))+
  ggtitle(expression(Delta^{15}*N[proto]))+
  xlab(expression(delta^{15}*N~("\u2030")))+
  facet_wrap(~AA, scales = "free", nrow = 2, labeller = as_labeller(labels2))+
  scale_x_continuous(n.breaks=4)+
  scale_color_manual(values = c("red3","steelblue"))+
  scale_fill_manual(values = c("steelblue","red3"))+
  labs(fill="True Value",color="95% HDI",shape="Literature Studies")+
  theme(axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        axis.title.y = element_blank(),plot.title = element_text(hjust = 0.5),
        legend.position = "none")

ggarrange(nrow=1, ncol=3, widths = c(16,1,4), common.legend = TRUE, legend="bottom",
          plot_TDF_meta, ggplot()+geom_blank()+theme_void(), plot_TDF_proto)

## plotting posterior δ15N values for organic matter sources compared to data
src.mn$Group <- c(Sources)
src.mn.long <- melt(src.mn, id.vars = "Group", variable.name = "AA", value.name = "d15N")
src.mn.long$Isotope <- substr(src.mn.long$AA, start=1, stop=4)
src.mn.long$AA <- factor(substr(src.mn.long$AA, start=5, stop=7), levels = allAA)
tracers_mixing.AA <- factor(substr(tracers_mixing, start=5, stop=7), levels = allAA)
samples_d15N <- subset(posts.global.long$mean_Sources$samples, Isotope == "d15N")
sources_d15N <- subset(sources.long, Isotope == "d15N")
samples_d13C <- subset(posts.global.long$mean_Sources$samples, Isotope == "d13C")
sources_d13C <- subset(sources.long, Isotope == "d13C")

plot_d15N_source <- 
  ggplot()+
  geom_density(data = samples_d15N[
    which(samples_d15N$AA %in% tracers_mixing.AA),],
               aes(x=d15N, fill=Group), alpha=0.8, color="grey10", size=0.5)+
  # geom_line(data = posts.global.long$mean_Sources$HDI95,
  #           aes(x=d15N, y=rep(c(0,0),ntracers_candv), color=""),
  #           size=2,lineend="round")+
  # geom_point(data=src.mn.long[
  #   which(src.mn.long$Isotope=="d15N"),][
  #     which(src.mn.long$AA %in% tracers_mixing.AA),],
  #            aes(x=d15N, y=-0.5, fill=Group),
  #            shape=24,color="grey10",size=5,stroke=0.75,
  #            show.legend = FALSE)+
  geom_point(data=sources_d15N[
    which(sources_d15N$AA %in% tracers_mixing.AA),],
             aes(x=value, y=0, fill=Group, shape = "Source Data"),
             color="grey10",size=2,stroke=0.75,
             show.legend = FALSE)+
  scale_shape_manual(values=c(24))+
  # ggtitle(expression(Delta^{15}*N))+
  xlab(expression(delta^{15}*N~("\u2030")))+
  facet_wrap(~AA, scales = "free", nrow=2)+ #, labeller = as_labeller(labels1))+
  scale_x_continuous(n.breaks=4)+
  # scale_color_manual(values = c("red3","steelblue"))+
  # scale_fill_manual(values = c("steelblue","red3"))+
  labs(fill="Organic Matter Source",color="95% HDI")+
  theme(axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        axis.title.y = element_blank(),plot.title = element_text(hjust = 0.5),
        legend.position="bottom")
plot_d13C_source <- 
  ggplot()+
  geom_density(data = samples_d13C[
    which(samples_d13C$AA %in% tracers_mixing.AA),],
               aes(x=d15N, fill=Group), alpha=0.8, color="grey10", size=0.5)+
  # geom_line(data = posts.global.long$mean_Sources$HDI95,
  #           aes(x=d15N, y=rep(c(0,0),ntracers_candv), color=""),
  #           size=2,lineend="round")+
  # geom_point(data=src.mn.long[which(src.mn.long$Isotope=="d13C"),],
  #            aes(x=d15N, y=-0.5, fill=Group),
  #            shape=24,color="grey10",size=5,stroke=0.75,
  #            show.legend = FALSE)+
  geom_point(data=sources_d13C[
    which(sources_d13C$AA %in% tracers_mixing.AA),],
             aes(x=value, y=0, fill=Group, shape = "Source Data"),
             color="grey10",size=2,stroke=0.75,
             show.legend = FALSE)+
  scale_shape_manual(values=c(24))+
  # ggtitle(expression(Delta^{15}*N))+
  xlab(expression(delta^{13}*C~("\u2030")))+
  facet_wrap(~AA, scales = "free", nrow=2)+ #, labeller = as_labeller(labels1))+
  scale_x_continuous(n.breaks=4)+
  # scale_color_manual(values = c("red3","steelblue"))+
  # scale_fill_manual(values = c("steelblue","red3"))+
  labs(fill="Organic Matter Source",color="95% HDI")+
  theme(axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        axis.title.y = element_blank(),plot.title = element_text(hjust = 0.5),
        legend.position="bottom")

if(include_d13C==TRUE){
ggarrange(nrow=1, ncol=3, widths = c(12,1,6), common.legend = TRUE, legend="bottom",
          plot_d15N_source, ggplot()+geom_blank()+theme_void(), plot_d13C_source)
}else{plot_d15N_source}

# ggplot()+
#   geom_density(data = posts_1[["samples"]][["mean_Sources"]],
#                aes(x=d15NGlx,
#                    group=Group,fill=Group))+
#   ylab("Probability Density")
# 
# ggplot()+
#   geom_density(data = posts_1[["samples"]][["zoops"]],
#                aes(x=Large))+
#   ylab("Probability Density")+
#   facet_wrap(~Group, scales="free_y")
# 
# ggplot()+
#   geom_density(data = posts_1[["samples"]][["zoops"]],
#                aes(x=FWL))+
#   ylab("Probability Density")+
#   facet_wrap(~Group, scales="free_y")+
#   coord_cartesian(xlim=c(0,5))

```



## MCMC zooplankton parameter posteriors {-}

```{r MCMC_zoop_param_extract}
## 2. Zooplankton food web parameter posteriors (mixing coefficients, trophic positions, and δ15N values at the base of the food web) ##
sams <- as.matrix(rjo_1$mcmc)
# we'll make a list which contains samples and summary data for each posterior
posts.zoops <- list(
  f = list(
    samples = data.frame(matrix(nrow = nsams,ncol=0)),
    HDI95 = data.frame(matrix(nrow = 2,ncol=0)),
    HDI90 = data.frame(matrix(nrow = 2,ncol=0)),
    HDI75 = data.frame(matrix(nrow = 2,ncol=0)),
    HDI50 = data.frame(matrix(nrow = 2,ncol=0)),
    mean = data.frame(matrix(nrow = 1,ncol=0)),
    mode = data.frame(matrix(nrow = 1,ncol=0))
  ),
  trophic = list(
    samples = data.frame(matrix(nrow = nsams,ncol=0)),
    HDI95 = data.frame(matrix(nrow = 2,ncol=0)),
    HDI90 = data.frame(matrix(nrow = 2,ncol=0)),
    HDI75 = data.frame(matrix(nrow = 2,ncol=0)),
    HDI50 = data.frame(matrix(nrow = 2,ncol=0)),
    mean = data.frame(matrix(nrow = 1,ncol=0)),
    mode = data.frame(matrix(nrow = 1,ncol=0))
  ),
  base = list(
    samples = data.frame(matrix(nrow = nsams*nsources,ncol=0)),
    HDI95 = data.frame(matrix(nrow = nsources*2,ncol=0)),
    HDI90 = data.frame(matrix(nrow = nsources*2,ncol=0)),
    HDI75 = data.frame(matrix(nrow = nsources*2,ncol=0)),
    HDI50 = data.frame(matrix(nrow = nsources*2,ncol=0)),
    mean = data.frame(matrix(nrow = nsources,ncol=0)),
    mode = data.frame(matrix(nrow = nsources,ncol=0))
  ),
  zoop = list(
    samples = data.frame(matrix(nrow = nsams*nzoops,ncol=0)),
    HDI95 = data.frame(matrix(nrow = nzoops*2,ncol=0)),
    HDI90 = data.frame(matrix(nrow = nzoops*2,ncol=0)),
    HDI75 = data.frame(matrix(nrow = nzoops*2,ncol=0)),
    HDI50 = data.frame(matrix(nrow = nzoops*2,ncol=0)),
    mean = data.frame(matrix(nrow = nzoops,ncol=0)),
    mode = data.frame(matrix(nrow = nzoops,ncol=0))
  )
)

# grabbing f(source) posteriors
temp1<-data.frame(matrix(ncol=length(variables),nrow=nzoops*nsams))
temp2<-data.frame(matrix(ncol=length(variables),nrow=nzoops*2))
temp3<-data.frame(matrix(ncol=length(variables),nrow=nzoops))
colnames(temp1)<-colnames(temp2)<-colnames(temp3)<-variables
# initial columns give info on each zooplankton sample
# Data_zoops$Size <- factor(Data_zoops$Size, levels = c("0.2-0.5 mm","0.5-1.0 mm","1-2 mm","2-5 mm",">5"))
for (j in 1:nzoops) {
  temp1[((j-1)*nsams+1):(nsams*j),] <- Data_zoops[j,variables]
  temp2[((j-1)*2+1):(2*j),] <- Data_zoops[j,variables]
  temp3[j,] <- Data_zoops[j,variables]
}
temp1$Size <- factor(temp1$Size, levels = c("0.2-0.5 mm","0.5-1.0 mm","1-2 mm","2-5 mm",">5 mm"))
temp2$Size <- factor(temp2$Size, levels = c("0.2-0.5 mm","0.5-1.0 mm","1-2 mm","2-5 mm",">5 mm"))
temp3$Size <- factor(temp3$Size, levels = c("0.2-0.5 mm","0.5-1.0 mm","1-2 mm","2-5 mm",">5 mm"))
posts.zoops$f$samples <- posts.zoops$trophic$samples <- posts.zoops$base$samples <- posts.zoops$zoop$samples <- temp1
posts.zoops$f$HDI95 <- posts.zoops$trophic$HDI95 <- posts.zoops$base$HDI95 <- posts.zoops$zoop$HDI95 <-
  posts.zoops$f$HDI90 <- posts.zoops$trophic$HDI90 <- posts.zoops$base$HDI90 <- posts.zoops$zoop$HDI90 <-
  posts.zoops$f$HDI75 <- posts.zoops$trophic$HDI75 <- posts.zoops$base$HDI75 <- posts.zoops$zoop$HDI75 <-
  posts.zoops$f$HDI50 <- posts.zoops$trophic$HDI50 <- posts.zoops$base$HDI50 <- posts.zoops$zoop$HDI50 <- temp2
posts.zoops$f$mean <- posts.zoops$trophic$mean <- posts.zoops$base$mean <- posts.zoops$zoop$mean <-
  posts.zoops$f$mode <- posts.zoops$trophic$mode <- posts.zoops$base$mode <- posts.zoops$zoop$mode <- temp3

# next columns give respective f data for each source
for (j in 1:nsources) {
  temp1<-temp2<-temp3<-temp4<-temp5<-temp6<-temp7<-c()
  for (i in 1:nzoops) {
    temp1 <- c(temp1, sams[,paste("pz[",i,",",j,"]",sep = "")])
    temp2 <- c(temp2, HDIofMCMC(sams[,paste("pz[",i,",",j,"]",sep = "")], credMass=0.95))
    temp3 <- c(temp3, HDIofMCMC(sams[,paste("pz[",i,",",j,"]",sep = "")], credMass=0.90))
    temp4 <- c(temp4, HDIofMCMC(sams[,paste("pz[",i,",",j,"]",sep = "")], credMass=0.75))
    temp5 <- c(temp5, HDIofMCMC(sams[,paste("pz[",i,",",j,"]",sep = "")], credMass=0.50))
    temp6 <- c(temp6, mean(sams[,paste("pz[",i,",",j,"]",sep = "")]))
    temp7 <- c(temp7, post.mode(sams[,paste("pz[",i,",",j,"]",sep = "")]))
  }
  posts.zoops$f$samples[Sources[j]] <- temp1
  posts.zoops$f$HDI95[Sources[j]] <- temp2
  posts.zoops$f$HDI90[Sources[j]] <- temp3
  posts.zoops$f$HDI75[Sources[j]] <- temp4
  posts.zoops$f$HDI50[Sources[j]] <- temp5
  posts.zoops$f$mean[Sources[j]] <- temp6
  posts.zoops$f$mode[Sources[j]] <- temp7
}
# next columns give respective trophic parameters
trophs <- c("FWL","PTS","MTS")
for (j in 1:length(trophs)) {
  temp1<-temp2<-temp3<-temp4<-temp5<-temp6<-temp7<-c()
  for (i in 1:nzoops) {
    temp1 <- c(temp1, sams[,paste(trophs[j],"[",i,"]",sep = "")])
    temp2 <- c(temp2, HDIofMCMC(sams[,paste(trophs[j],"[",i,"]",sep = "")], credMass=0.95))
    temp3 <- c(temp3, HDIofMCMC(sams[,paste(trophs[j],"[",i,"]",sep = "")], credMass=0.90))
    temp4 <- c(temp4, HDIofMCMC(sams[,paste(trophs[j],"[",i,"]",sep = "")], credMass=0.75))
    temp5 <- c(temp5, HDIofMCMC(sams[,paste(trophs[j],"[",i,"]",sep = "")], credMass=0.50))
    temp6 <- c(temp6, mean(sams[,paste(trophs[j],"[",i,"]",sep = "")]))
    temp7 <- c(temp7, post.mode(sams[,paste(trophs[j],"[",i,"]",sep = "")]))
  }
  posts.zoops$trophic$samples[trophs[j]] <- temp1
  posts.zoops$trophic$HDI95[trophs[j]] <- temp2
  posts.zoops$trophic$HDI90[trophs[j]] <- temp3
  posts.zoops$trophic$HDI75[trophs[j]] <- temp4
  posts.zoops$trophic$HDI50[trophs[j]] <- temp5
  posts.zoops$trophic$mean[trophs[j]] <- temp6
  posts.zoops$trophic$mode[trophs[j]] <- temp7
}
# next columns give respective δ15N_base values
for (j in 1:ntracers) {
  temp1<-temp2<-temp3<-temp4<-temp5<-temp6<-temp7<-c()
  for (i in 1:nzoops) {
    temp1 <- c(temp1, sams[,paste("mean_b[",i,",",j,"]",sep = "")])
    temp2 <- c(temp2, HDIofMCMC(sams[,paste("mean_b[",i,",",j,"]",sep = "")], credMass=0.95))
    temp3 <- c(temp3, HDIofMCMC(sams[,paste("mean_b[",i,",",j,"]",sep = "")], credMass=0.90))
    temp4 <- c(temp4, HDIofMCMC(sams[,paste("mean_b[",i,",",j,"]",sep = "")], credMass=0.75))
    temp5 <- c(temp5, HDIofMCMC(sams[,paste("mean_b[",i,",",j,"]",sep = "")], credMass=0.50))
    temp6 <- c(temp6, mean(sams[,paste("mean_b[",i,",",j,"]",sep = "")]))
    temp7 <- c(temp7, post.mode(sams[,paste("mean_b[",i,",",j,"]",sep = "")]))
  }
  posts.zoops$base$samples[tracers[j]] <- temp1
  posts.zoops$base$HDI95[tracers[j]] <- temp2
  posts.zoops$base$HDI90[tracers[j]] <- temp3
  posts.zoops$base$HDI75[tracers[j]] <- temp4
  posts.zoops$base$HDI50[tracers[j]] <- temp5
  posts.zoops$base$mean[tracers[j]] <- temp6
  posts.zoops$base$mode[tracers[j]] <- temp7
}
# next columns give respective δ15N_zoop values
for (j in 1:ntracers) {
  temp1<-temp2<-temp3<-temp4<-temp5<-temp6<-temp7<-c()
  for (i in 1:nzoops) {
    temp1 <- c(temp1, sams[,paste("mean_z[",i,",",j,"]",sep = "")])
    temp2 <- c(temp2, HDIofMCMC(sams[,paste("mean_z[",i,",",j,"]",sep = "")], credMass=0.95))
    temp3 <- c(temp3, HDIofMCMC(sams[,paste("mean_z[",i,",",j,"]",sep = "")], credMass=0.90))
    temp4 <- c(temp4, HDIofMCMC(sams[,paste("mean_z[",i,",",j,"]",sep = "")], credMass=0.75))
    temp5 <- c(temp5, HDIofMCMC(sams[,paste("mean_z[",i,",",j,"]",sep = "")], credMass=0.50))
    temp6 <- c(temp6, mean(sams[,paste("mean_z[",i,",",j,"]",sep = "")]))
    temp7 <- c(temp7, post.mode(sams[,paste("mean_z[",i,",",j,"]",sep = "")]))
  }
  posts.zoops$zoop$samples[tracers[j]] <- temp1
  posts.zoops$zoop$HDI95[tracers[j]] <- temp2
  posts.zoops$zoop$HDI90[tracers[j]] <- temp3
  posts.zoops$zoop$HDI75[tracers[j]] <- temp4
  posts.zoops$zoop$HDI50[tracers[j]] <- temp5
  posts.zoops$zoop$mean[tracers[j]] <- temp6
  posts.zoops$zoop$mode[tracers[j]] <- temp7
}

# at times we will want thinned samlpes for plotting purposes
thin.by <- round(samsPerChain/100,0) # will select 1 out of every n samples
thin.f <- seq(1,nrow(posts.zoops$f$samples),thin.by)
posts.zoops$f$thin <- posts.zoops$f$samples[thin.f,]
thin.trophic <- seq(1,nrow(posts.zoops$trophic$samples),thin.by)
posts.zoops$trophic$thin <- posts.zoops$trophic$samples[thin.trophic,]
thin.base <- seq(1,nrow(posts.zoops$base$samples),thin.by)
posts.zoops$base$thin <- posts.zoops$base$samples[thin.base,]
thin.zoop <- seq(1,nrow(posts.zoops$zoop$samples),thin.by)
posts.zoops$zoop$thin <- posts.zoops$zoop$samples[thin.zoop,]

# at times we'll want this data in long format so we'll handle that here as well
posts.zoops.long <- list(
  f = list(
    samples = melt(posts.zoops$f$samples, 
                   id.vars = variables, value.name = "f", variable.name = "Source"),
    thin = melt(posts.zoops$f$thin, 
                   id.vars = variables, value.name = "f", variable.name = "Source"),
    HDI95 = melt(posts.zoops$f$HDI95, 
               id.vars = variables, value.name = "f", variable.name = "Source"),
    HDI90 = melt(posts.zoops$f$HDI90, 
               id.vars = variables, value.name = "f", variable.name = "Source"),
    HDI75 = melt(posts.zoops$f$HDI75, 
               id.vars = variables, value.name = "f", variable.name = "Source"),
    HDI50 = melt(posts.zoops$f$HDI50, 
               id.vars = variables, value.name = "f", variable.name = "Source"),
    mean = melt(posts.zoops$f$mean, 
                id.vars = variables, value.name = "f", variable.name = "Source"),
    mode = melt(posts.zoops$f$mode, 
                id.vars = variables, value.name = "f", variable.name = "Source")
  ),
  trophic = list(
    samples = melt(posts.zoops$trophic$samples, 
                   id.vars = variables, value.name = "Value", variable.name = "Param"),
    thin = melt(posts.zoops$trophic$thin, 
                   id.vars = variables, value.name = "Value", variable.name = "Param"),
    HDI95 = melt(posts.zoops$trophic$HDI95, 
               id.vars = variables, value.name = "Value", variable.name = "Param"),
    HDI90 = melt(posts.zoops$trophic$HDI90, 
               id.vars = variables, value.name = "Value", variable.name = "Param"),
    HDI75 = melt(posts.zoops$trophic$HDI75, 
               id.vars = variables, value.name = "Value", variable.name = "Param"),
    HDI50 = melt(posts.zoops$trophic$HDI50, 
               id.vars = variables, value.name = "Value", variable.name = "Param"),
    mean = melt(posts.zoops$trophic$mean, 
                id.vars = variables, value.name = "Value", variable.name = "Param"),
    mode = melt(posts.zoops$trophic$mode, 
                id.vars = variables, value.name = "Value", variable.name = "Param")
  ),
  base = list(
    samples = melt(posts.zoops$base$samples, 
                   id.vars = variables, value.name = "Value", variable.name = "AA"),
    thin = melt(posts.zoops$base$thin, 
                   id.vars = variables, value.name = "Value", variable.name = "AA"),
    HDI95 = melt(posts.zoops$base$HDI95, 
                   id.vars = variables, value.name = "Value", variable.name = "AA"),
    HDI90 = melt(posts.zoops$base$HDI90, 
                   id.vars = variables, value.name = "Value", variable.name = "AA"),
    HDI75 = melt(posts.zoops$base$HDI75, 
                   id.vars = variables, value.name = "Value", variable.name = "AA"),
    HDI50 = melt(posts.zoops$base$HDI50, 
                   id.vars = variables, value.name = "Value", variable.name = "AA"),
    mean = melt(posts.zoops$base$mean, 
                   id.vars = variables, value.name = "Value", variable.name = "AA"),
    mode = melt(posts.zoops$base$mode, 
                   id.vars = variables, value.name = "Value", variable.name = "AA")
  ),
  zoop = list(
    samples = melt(posts.zoops$zoop$samples, 
                   id.vars = variables, value.name = "Value", variable.name = "AA"),
    thin = melt(posts.zoops$zoop$thin, 
                   id.vars = variables, value.name = "Value", variable.name = "AA"),
    HDI95 = melt(posts.zoops$zoop$HDI95, 
                   id.vars = variables, value.name = "Value", variable.name = "AA"),
    HDI90 = melt(posts.zoops$zoop$HDI90, 
                   id.vars = variables, value.name = "Value", variable.name = "AA"),
    HDI75 = melt(posts.zoops$zoop$HDI75, 
                   id.vars = variables, value.name = "Value", variable.name = "AA"),
    HDI50 = melt(posts.zoops$zoop$HDI50, 
                   id.vars = variables, value.name = "Value", variable.name = "AA"),
    mean = melt(posts.zoops$zoop$mean, 
                   id.vars = variables, value.name = "Value", variable.name = "AA"),
    mode = melt(posts.zoops$zoop$mode, 
                   id.vars = variables, value.name = "Value", variable.name = "AA")
  )
)

# We also want separate columns indicating the AA and the isotope in long format
posts.zoops.long$base$samples$Isotope <- substr(posts.zoops.long$base$samples$AA,
                                                     start=1, stop=4)
posts.zoops.long$base$samples$AA <- factor(substr(posts.zoops.long$base$samples$AA,
                                                     start=5, stop=7), levels = allAA)
posts.zoops.long$base$thin$Isotope <- substr(posts.zoops.long$base$thin$AA,
                                                     start=1, stop=4)
posts.zoops.long$base$thin$AA <- factor(substr(posts.zoops.long$base$thin$AA,
                                                     start=5, stop=7), levels = allAA)
posts.zoops.long$base$HDI95$Isotope <- substr(posts.zoops.long$base$HDI95$AA,
                                                     start=1, stop=4)
posts.zoops.long$base$HDI95$AA <- factor(substr(posts.zoops.long$base$HDI95$AA,
                                                     start=5, stop=7), levels = allAA)
posts.zoops.long$base$HDI90$Isotope <- substr(posts.zoops.long$base$HDI90$AA,
                                                     start=1, stop=4)
posts.zoops.long$base$HDI90$AA <- factor(substr(posts.zoops.long$base$HDI90$AA,
                                                     start=5, stop=7), levels = allAA)
posts.zoops.long$base$HDI75$Isotope <- substr(posts.zoops.long$base$HDI75$AA,
                                                     start=1, stop=4)
posts.zoops.long$base$HDI75$AA <- factor(substr(posts.zoops.long$base$HDI75$AA,
                                                     start=5, stop=7), levels = allAA)
posts.zoops.long$base$HDI50$Isotope <- substr(posts.zoops.long$base$HDI50$AA,
                                                     start=1, stop=4)
posts.zoops.long$base$HDI50$AA <- factor(substr(posts.zoops.long$base$HDI50$AA,
                                                     start=5, stop=7), levels = allAA)
posts.zoops.long$base$mean$Isotope <- substr(posts.zoops.long$base$mean$AA,
                                                     start=1, stop=4)
posts.zoops.long$base$mean$AA <- factor(substr(posts.zoops.long$base$mean$AA,
                                                     start=5, stop=7), levels = allAA)
posts.zoops.long$base$mode$Isotope <- substr(posts.zoops.long$base$mode$AA,
                                                     start=1, stop=4)
posts.zoops.long$base$mode$AA <- factor(substr(posts.zoops.long$base$mode$AA,
                                                     start=5, stop=7), levels = allAA)

posts.zoops.long$zoop$samples$Isotope <- substr(posts.zoops.long$zoop$samples$AA,
                                                     start=1, stop=4)
posts.zoops.long$zoop$samples$AA <- factor(substr(posts.zoops.long$zoop$samples$AA,
                                                     start=5, stop=7), levels = allAA)
posts.zoops.long$zoop$thin$Isotope <- substr(posts.zoops.long$zoop$thin$AA,
                                                     start=1, stop=4)
posts.zoops.long$zoop$thin$AA <- factor(substr(posts.zoops.long$zoop$thin$AA,
                                                     start=5, stop=7), levels = allAA)
posts.zoops.long$zoop$HDI95$Isotope <- substr(posts.zoops.long$zoop$HDI95$AA,
                                                     start=1, stop=4)
posts.zoops.long$zoop$HDI95$AA <- factor(substr(posts.zoops.long$zoop$HDI95$AA,
                                                     start=5, stop=7), levels = allAA)
posts.zoops.long$zoop$HDI90$Isotope <- substr(posts.zoops.long$zoop$HDI90$AA,
                                                     start=1, stop=4)
posts.zoops.long$zoop$HDI90$AA <- factor(substr(posts.zoops.long$zoop$HDI90$AA,
                                                     start=5, stop=7), levels = allAA)
posts.zoops.long$zoop$HDI75$Isotope <- substr(posts.zoops.long$zoop$HDI75$AA,
                                                     start=1, stop=4)
posts.zoops.long$zoop$HDI75$AA <- factor(substr(posts.zoops.long$zoop$HDI75$AA,
                                                     start=5, stop=7), levels = allAA)
posts.zoops.long$zoop$HDI50$Isotope <- substr(posts.zoops.long$zoop$HDI50$AA,
                                                     start=1, stop=4)
posts.zoops.long$zoop$HDI50$AA <- factor(substr(posts.zoops.long$zoop$HDI50$AA,
                                                     start=5, stop=7), levels = allAA)
posts.zoops.long$zoop$mean$Isotope <- substr(posts.zoops.long$zoop$mean$AA,
                                                     start=1, stop=4)
posts.zoops.long$zoop$mean$AA <- factor(substr(posts.zoops.long$zoop$mean$AA,
                                                     start=5, stop=7), levels = allAA)
posts.zoops.long$zoop$mode$Isotope <- substr(posts.zoops.long$zoop$mode$AA,
                                                     start=1, stop=4)
posts.zoops.long$zoop$mode$AA <- factor(substr(posts.zoops.long$zoop$mode$AA,
                                                     start=5, stop=7), levels = allAA)

# last, we will at times want to pool two mixing parameters to fit on a ternary diagram
# Large + Small particles
temp1<-temp2<-temp3<-temp4<-temp5<-temp6<-temp7<- c()
for (i in 1:nzoops) {
    temp1 <- c(temp1, sams[,paste("pz[",i,",2]",sep = "")]+sams[,paste("pz[",i,",3]",sep = "")])
    temp2 <- 
      c(temp2, HDIofMCMC(sams[,paste("pz[",i,",2]",sep = "")]+
                           sams[,paste("pz[",i,",3]",sep = "")], credMass=0.95))
    temp3 <- 
      c(temp3, HDIofMCMC(sams[,paste("pz[",i,",2]",sep = "")]+
                           sams[,paste("pz[",i,",3]",sep = "")], credMass=0.90))
    temp4 <- 
      c(temp4, HDIofMCMC(sams[,paste("pz[",i,",2]",sep = "")]+
                           sams[,paste("pz[",i,",3]",sep = "")], credMass=0.75))
    temp5 <- 
      c(temp5, HDIofMCMC(sams[,paste("pz[",i,",2]",sep = "")]+
                           sams[,paste("pz[",i,",3]",sep = "")], credMass=0.50))
    temp6 <- 
      c(temp6, mean(sams[,paste("pz[",i,",2]",sep = "")]+
                      sams[,paste("pz[",i,",3]",sep = "")]))
    temp7 <- 
      c(temp7, post.mode(sams[,paste("pz[",i,",2]",sep = "")]+
                           sams[,paste("pz[",i,",3]",sep = "")]))
  }
  posts.zoops$f$samples$LargeSmall <- temp1
  posts.zoops$f$HDI95$LargeSmall <- temp2
  posts.zoops$f$HDI90$LargeSmall <- temp3
  posts.zoops$f$HDI75$LargeSmall <- temp4
  posts.zoops$f$HDI50$LargeSmall <- temp5
  posts.zoops$f$mean$LargeSmall <- temp6
  posts.zoops$f$mode$LargeSmall <- temp7
  
# Small + Submicron particles
temp1<-temp2<-temp3<-temp4<-temp5<-temp6<-temp7<- c()
for (i in 1:nzoops) {
    temp1 <- c(temp1, sams[,paste("pz[",i,",4]",sep = "")]+
                 sams[,paste("pz[",i,",3]",sep = "")])
    temp2 <- 
      c(temp2, HDIofMCMC(sams[,paste("pz[",i,",4]",sep = "")]+
                           sams[,paste("pz[",i,",3]",sep = "")], credMass=0.95))
    temp3 <- 
      c(temp3, HDIofMCMC(sams[,paste("pz[",i,",4]",sep = "")]+
                           sams[,paste("pz[",i,",3]",sep = "")], credMass=0.90))
    temp4 <- 
      c(temp4, HDIofMCMC(sams[,paste("pz[",i,",4]",sep = "")]+
                           sams[,paste("pz[",i,",3]",sep = "")], credMass=0.75))
    temp5 <- 
      c(temp5, HDIofMCMC(sams[,paste("pz[",i,",4]",sep = "")]+
                           sams[,paste("pz[",i,",3]",sep = "")], credMass=0.50))
    temp6 <- 
      c(temp6, mean(sams[,paste("pz[",i,",4]",sep = "")]+
                      sams[,paste("pz[",i,",3]",sep = "")]))
    temp7 <- 
      c(temp7, post.mode(sams[,paste("pz[",i,",4]",sep = "")]+
                           sams[,paste("pz[",i,",3]",sep = "")]))
  }
  posts.zoops$f$samples$SmallSub <- temp1
  posts.zoops$f$HDI95$SmallSub <- temp2
  posts.zoops$f$HDI90$SmallSub <- temp3
  posts.zoops$f$HDI75$SmallSub <- temp4
  posts.zoops$f$HDI50$SmallSub <- temp5
  posts.zoops$f$mean$SmallSub <- temp6
  posts.zoops$f$mode$SmallSub <- temp7
  
# Large + Surface particles
temp1<-temp2<-temp3<-temp4<-temp5<-temp6<-temp7<- c()
for (i in 1:nzoops) {
    temp1 <- c(temp1, sams[,paste("pz[",i,",1]",sep = "")]+
                 sams[,paste("pz[",i,",2]",sep = "")])
    temp2 <- 
      c(temp2, HDIofMCMC(sams[,paste("pz[",i,",1]",sep = "")]+
                           sams[,paste("pz[",i,",2]",sep = "")], credMass=0.95))
    temp3 <- 
      c(temp3, HDIofMCMC(sams[,paste("pz[",i,",1]",sep = "")]+
                           sams[,paste("pz[",i,",2]",sep = "")], credMass=0.90))
    temp4 <- 
      c(temp4, HDIofMCMC(sams[,paste("pz[",i,",1]",sep = "")]+
                           sams[,paste("pz[",i,",2]",sep = "")], credMass=0.75))
    temp5 <- 
      c(temp5, HDIofMCMC(sams[,paste("pz[",i,",1]",sep = "")]+
                           sams[,paste("pz[",i,",2]",sep = "")], credMass=0.50))
    temp6 <- 
      c(temp6, mean(sams[,paste("pz[",i,",1]",sep = "")]+
                      sams[,paste("pz[",i,",2]",sep = "")]))
    temp7 <- 
      c(temp7, post.mode(sams[,paste("pz[",i,",1]",sep = "")]+
                           sams[,paste("pz[",i,",2]",sep = "")]))
  }
  posts.zoops$f$samples$SurfLarge <- temp1
  posts.zoops$f$HDI95$SurfLarge <- temp2
  posts.zoops$f$HDI90$SurfLarge <- temp3
  posts.zoops$f$HDI75$SurfLarge <- temp4
  posts.zoops$f$HDI50$SurfLarge <- temp5
  posts.zoops$f$mean$SurfLarge <- temp6
  posts.zoops$f$mode$SurfLarge <- temp7
  
```

Now let's generate plots of the MCMC posteriors for the zooplankton sample-specific parameters. We'll want to plot the model posteriors for the $\dNAA$ and $\dCAA$ values at the base of the food web. We'll do this for all the individual AAs, but also try and visualize the multivariate patterns using LDA.

```{r posterior_base, dpi=300, fig.asp=0.6, fig.width=8.5}

## Generating AA δ15N comparison plot
posts.zoops.long$base$thin$Group <- as.factor(posts.zoops.long$base$thin$Group)
  
AAplots <-
  ggplot(sources.long)+
  geom_point(aes(x = AA, y = value, color = Group),
             position = position_nudge(x = 0.3))+
  geom_point(data = zoops.long,
             aes(x = AA, y = value, fill="simulated zooplankton"), pch = "triangle",
             position = position_nudge(x = -0.3))+
  geom_point(data = posts.zoops.long$base$thin,
             aes(x = AA, y = Value), color = "grey60", alpha=0.1, pch=16,
             position = position_dodge2(width=0.2))+
  geom_point(data = posts.zoops.long$base$mean,
             aes(x = AA, y = Value, shape="posterior mean"), color = "brown", alpha=1,
             position = position_dodge2(width = 0.2))+
  ylab(expression(delta^{15}*N*" (\u2030)"))+
  labs(color="Organic Matter Source", shape="Food Web Base", fill="Zooplankton Samples")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.3, hjust=1))+
  facet_row(~Isotope, scales="free", space="free")
AAplots

## Generating LDA comparison plot
# poject zooplankton into LD space and predict classification
pred.base.MCMC = predict(LDA.full, 
                         posts.zoops$base$mode)
#class.zoops = data.frame('Class' = pred.zoops$class, pred.zoops$x)
# generate data frame which stores predicted classification of particles indexed by size and depth
class.base.MCMC = data.frame('Predicted' = pred.base.MCMC$class, pred.base.MCMC$x,
                             lapply(posts.zoops$base$mean[variables],as.character))
# # Predicted probabilities of class membership
# head(pred.base.MCMC$posterior,n=dim(pred.base.MCMC$posterior))
# # linear discriminants
# head(pred.base.MCMC$x,n=dim(pred.base.MCMC$x))

pred.base.sams <- predict(LDA.full,
                          posts.zoops$base$thin[tracers])
# generate data frame which stores predicted classification of particles indexed by size and depth
class.base.sams = data.frame('Predicted' = pred.base.sams$class, pred.base.sams$x,
                             lapply(posts.zoops$base$thin[variables],as.character))
# Predicted probabilities of class membership
# head(pred.base.sams$posterior,n=dim(pred.base.sams$posterior))
# linear discriminants
# head(pred.base.sams$x,n=dim(pred.base.sams$x))

ggplot(data = class.train, 
                       aes(x = LD2, y = LD1), size = 2) + 
  geom_point(aes(shape=Type), alpha = 1, color="grey20") +
  stat_ellipse(aes(group=Type),type = 't', alpha = 0.8)+
  stat_ellipse(data = class.base.sams,
             aes(x = LD2, y = LD1, 
                 color=interaction(Size,Depth), fill=interaction(Size,Depth)),
             type = 't', alpha = 0.3, size=0.5, geom = "polygon")+
  geom_point(data = class.base.MCMC,
             aes(x = LD2, y = LD1, fill=interaction(Size,Depth)),
             size=3.5, shape=23, stroke=1)+
  labs(fill = "Posterior 95% HDI and Mode",
       color = "Zooplankton Sample",
       shape = "Organic Matter Source"
       )+
  guides(color=FALSE)

# ggplot(data = class.train, 
#                        aes(x = LD2, y = LD1), size = 2) + 
#   geom_point(aes(shape=Type), alpha = 0.6) +
#   stat_ellipse(aes(group=Type),type = 't', alpha = 0.8)+
#   stat_ellipse(data = class.base.sams,
#              aes(x = LD2, y = LD1, color=Group, fill=Group),
#              type = 't', alpha = 0.5, size=0.5, geom = "polygon")+
#   geom_point(data = class.base.sams,
#              aes(x = LD2, y = LD1, fill=interaction(Size,Depth)), shape=23, alpha=0.1)+
#   geom_point(data = class.base.MCMC,
#              aes(x = LD2, y = LD1, fill=interaction(Size,Depth)),
#              size=3, shape=23, stroke=1)+
#   labs(fill = "Zooplankton Sample",
#        color = "Zooplankton Sample",
#        shape = "Organic Matter Source"
#        )+
#   guides(color=FALSE,fill=FALSE)

```

We also want to look at the mean_z parameter for each zooplankton sample to see if and where the posteriors are deviating from the data.

```{r posterior_zoop, dpi=300, fig.asp=0.6, fig.width=8.5}

## Generating AA δ15N comparison plot
posts.zoops.long$zoop$thin$Group <- as.factor(posts.zoops.long$zoop$thin$Group)
  
AAplots <-
  ggplot(sources.long)+
  geom_point(aes(x = AA, y = value, color = Group),
             position = position_nudge(x = 0.3))+
  geom_point(data = zoops.long,
             aes(x = AA, y = value, fill="simulated zooplankton"), pch = "triangle",
             position = position_nudge(x = -0.3))+
  geom_point(data = posts.zoops.long$zoop$thin,
             aes(x = AA, y = Value), color = "grey60", alpha=0.1, pch=16,
             position = position_dodge2(width=0.2))+
  geom_point(data = posts.zoops.long$zoop$mean,
             aes(x = AA, y = Value, shape="posterior mean"), color = "brown", alpha=1,
             position = position_dodge2(width = 0.2))+
  ylab(expression(delta^{15}*N*" (\u2030)"))+
  labs(color="Organic Matter Source", shape="Zooplankton Posterior", fill="Zooplankton Samples")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.3, hjust=1))+
  facet_row(~Isotope, scales="free", space="free")
AAplots

# ## Generating LDA comparison plot
# # poject zooplankton into LD space and predict classification
# pred.base.MCMC = predict(LDA.full, 
#                          posts.zoops$base$mode)
# #class.zoops = data.frame('Class' = pred.zoops$class, pred.zoops$x)
# # generate data frame which stores predicted classification of particles indexed by size and depth
# class.base.MCMC = data.frame('Predicted' = pred.base.MCMC$class, pred.base.MCMC$x,
#                              lapply(posts.zoops$base$mean[variables],as.character))
# # # Predicted probabilities of class membership
# # head(pred.base.MCMC$posterior,n=dim(pred.base.MCMC$posterior))
# # # linear discriminants
# # head(pred.base.MCMC$x,n=dim(pred.base.MCMC$x))
# 
# pred.base.sams <- predict(LDA.full,
#                           posts.zoops$base$thin[tracers])
# # generate data frame which stores predicted classification of particles indexed by size and depth
# class.base.sams = data.frame('Predicted' = pred.base.sams$class, pred.base.sams$x,
#                              lapply(posts.zoops$base$thin[variables],as.character))
# # Predicted probabilities of class membership
# # head(pred.base.sams$posterior,n=dim(pred.base.sams$posterior))
# # linear discriminants
# # head(pred.base.sams$x,n=dim(pred.base.sams$x))
# 
# 
# 
# ggplot(data = class.train, 
#                        aes(x = LD2, y = LD1), size = 2) + 
#   geom_point(aes(shape=Type), alpha = 0.6) +
#   stat_ellipse(aes(group=Type),type = 't', alpha = 0.8)+
#   stat_ellipse(data = class.base.sams,
#              aes(x = LD2, y = LD1, color=interaction(Size,Depth), fill=interaction(Size,Depth)),
#              type = 't', alpha = 0.8, size=0.5)+
#   geom_point(data = class.base.sams,
#              aes(x = LD2, y = LD1, fill=interaction(Size,Depth)), shape=23, alpha=0.1)+
#   geom_point(data = class.base.MCMC,
#              aes(x = LD2, y = LD1, fill=interaction(Size,Depth)),
#              size=3, shape=23, stroke=1)+
#   labs(fill = "Zooplankton Sample",
#        color = "Zooplankton Sample",
#        shape = "Organic Matter Source"
#        )+
#   guides(color=FALSE,fill=FALSE)

```

We also want to plot up the model posteriors for trophic parameters.

```{r posterior_trophic, dpi=300, fig.asp=0.6, fig.width=8.5}

#### Food Web Length ####
plot.FWL <-
  ggplot()+
  geom_line(data = posts.zoops$trophic$HDI95,
            aes(x = FWL, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 0.5, size = 1,
            position = position_dodgev(height = 80))+
  geom_line(data = posts.zoops$trophic$HDI90,
            aes(x = FWL, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 0.7, size = 1.5,
            position = position_dodgev(height = 80))+
  geom_line(data = posts.zoops$trophic$HDI75,
            aes(x = FWL, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 0.9, size = 2,
            position = position_dodgev(height = 80))+
  geom_line(data = posts.zoops$trophic$HDI50,
            aes(x = FWL, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 1, size = 3,
            position = position_dodgev(height = 80))+
  geom_point(data = posts.zoops$trophic$mode,
             aes(x = FWL, y = Depth, group = interaction(Depth, Size), fill = Size),
             size = 3, shape = 22,
             position = position_dodgev(height = 80))+
  scale_y_reverse(breaks = c(0,100,200,300,400,500,750,1000)) + 
  scale_x_continuous(breaks = c(0,1,2,3,4,5,6,7,8,9,10))+
  coord_cartesian(xlim = c(0,NA))
#### Metazoan Trophic Steps ####
plot.MTS <-
  ggplot()+
  geom_line(data = posts.zoops$trophic$HDI95,
            aes(x = MTS, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 0.5, size = 1,
            position = position_dodgev(height = 80))+
  geom_line(data = posts.zoops$trophic$HDI90,
            aes(x = MTS, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 0.7, size = 1.5,
            position = position_dodgev(height = 80))+
  geom_line(data = posts.zoops$trophic$HDI75,
            aes(x = MTS, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 0.9, size = 2,
            position = position_dodgev(height = 80))+
  geom_line(data = posts.zoops$trophic$HDI50,
            aes(x = MTS, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 1, size = 3,
            position = position_dodgev(height = 80))+
  geom_point(data = posts.zoops$trophic$mode,
             aes(x = MTS, y = Depth, group = interaction(Depth, Size), fill = Size),
             size = 3, shape = 22,
             position = position_dodgev(height = 80))+
  scale_y_reverse(breaks = c(0,100,200,300,400,500,750,1000)) + 
  scale_x_continuous(breaks = c(0,1,2,3,4,5,6,7,8,9,10))+
  coord_cartesian(xlim = c(0,NA))
#### Protozoan Trophic Steps ####
plot.PTS <-
  ggplot()+
  geom_line(data = posts.zoops$trophic$HDI95,
            aes(x = PTS, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 0.5, size = 1,
            position = position_dodgev(height = 80))+
  geom_line(data = posts.zoops$trophic$HDI90,
            aes(x = PTS, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 0.7, size = 1.5,
            position = position_dodgev(height = 80))+
  geom_line(data = posts.zoops$trophic$HDI75,
            aes(x = PTS, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 0.9, size = 2,
            position = position_dodgev(height = 80))+
  geom_line(data = posts.zoops$trophic$HDI50,
            aes(x = PTS, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 1, size = 3,
            position = position_dodgev(height = 80))+
  geom_point(data = posts.zoops$trophic$mode,
             aes(x = PTS, y = Depth, group = interaction(Depth, Size), fill = Size),
             size = 3, shape = 22,
             position = position_dodgev(height = 80))+
  scale_y_reverse(breaks = c(0,100,200,300,400,500,750,1000)) + 
  scale_x_continuous(breaks = c(0,1,2,3,4,5,6,7,8,9,10))+
  coord_cartesian(xlim = c(0,NA))

ggarrange(plot.FWL,
          plot.MTS+no.y.axis,
          plot.PTS+no.y.axis,
          nrow=1, widths = c(1.2,1,1), common.legend = TRUE, legend="top")

```

Last we'll do the same for mixing parameters. Here we'll generate simple box plots, but also ternary plots with two of the four organic matter sources pooled on one axis.

```{r posterior_f_ternary, eval=TRUE, dpi=300, fig.asp=0.82, fig.width=8.5}

## Making ternary plots of mixing parameters

posts.zoops$f$samples$model <- "vague prior"

ggtern(data = posts.zoops$f$samples,
       aes(x=Surface,
           y=LargeSmall,
           z=Submicron))+
  stat_confidence_tern(aes(fill=model), color="grey20", alpha=0.4, size=0,
                       breaks=c(0.95,0.90,0.75,0.50), geom = "polygon")+
  scale_fill_manual(values=c("steelblue1","steelblue4"))+
  geom_point(data = posts.zoops$f$mode,
             aes(x=Surface, y=LargeSmall, z=Submicron),
             size = 3, shape = 24, fill="steelblue1")+
  theme_bw()+
  theme(legend.box="vertical",
        legend.position = "right",
        tern.axis.title.T=element_blank(),
        tern.axis.title.L=element_blank(),
        tern.axis.title.R=element_blank())+
  theme_arrowlarge()+
  scale_shape_manual(values = c(24))+
  labs(fill="Model Posterior",shape="True Value",color="95% HDI")+
  facet_grid(rows = vars(Depth), cols = vars(Size))

ggtern(data = posts.zoops$f$samples,
       aes(x=SurfLarge,
           y=Small,
           z=Submicron))+
  stat_confidence_tern(aes(fill=model), color="grey20", alpha=0.4, size=0,
                       breaks=c(0.95,0.90,0.75,0.50), geom = "polygon")+
  scale_fill_manual(values=c("steelblue1","steelblue4"))+
  geom_point(data = posts.zoops$f$mode,
             aes(x=SurfLarge, y=Small, z=Submicron),
             size = 3, shape = 24, fill="steelblue1")+
  theme_bw()+
  theme(legend.box="vertical",
        legend.position = "right",
        tern.axis.title.T=element_blank(),
        tern.axis.title.L=element_blank(),
        tern.axis.title.R=element_blank())+
  theme_arrowlarge()+
  scale_shape_manual(values = c(24))+
  labs(fill="Model Posterior",shape="True Value",color="95% HDI")+
  facet_grid(rows = vars(Depth), cols = vars(Size))

ggtern(data = posts.zoops$f$samples,
       aes(x=Surface,
           y=Large,
           z=SmallSub))+
  stat_confidence_tern(aes(fill=model), color="grey20", alpha=0.4, size=0,
                       breaks=c(0.95,0.90,0.75,0.50), geom = "polygon")+
  scale_fill_manual(values=c("steelblue1","steelblue4"))+
  geom_point(data = posts.zoops$f$mode,
             aes(x=Surface, y=Large, z=SmallSub),
             size = 3, shape = 24, fill="steelblue1")+
  theme_bw()+
  theme(legend.box="vertical",
        legend.position = "right",
        tern.axis.title.T=element_blank(),
        tern.axis.title.L=element_blank(),
        tern.axis.title.R=element_blank())+
  theme_arrowlarge()+
  scale_shape_manual(values = c(24))+
  labs(fill="Model Posterior",shape="True Value",color="95% HDI")+
  facet_grid(rows = vars(Depth), cols = vars(Size))


```

```{r posterior_f_depth_profiles, eval=TRUE, dpi=300, fig.asp=0.5, fig.width=8.5}
#### f(Surface) ####
plot.Surface <-
  ggplot()+
  geom_line(data = posts.zoops$f$HDI95,
            aes(x = Surface, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 0.5, size = 1,
            position = position_dodgev(height = 80))+
  geom_line(data = posts.zoops$f$HDI90,
            aes(x = Surface, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 0.7, size = 1.5,
            position = position_dodgev(height = 80))+
  geom_line(data = posts.zoops$f$HDI75,
            aes(x = Surface, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 0.9, size = 2,
            position = position_dodgev(height = 80))+
  geom_line(data = posts.zoops$f$HDI50,
            aes(x = Surface, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 1, size = 3,
            position = position_dodgev(height = 80))+
  geom_point(data = posts.zoops$f$mode,
             aes(x = Surface, y = Depth, group = interaction(Depth, Size), fill = Size),
             size = 3, shape = 22,
             position = position_dodgev(height = 80))+
  scale_y_reverse(breaks = c(0,100,200,300,400,500,750,1000)) + 
  scale_x_continuous(breaks = c(0,0.50,1))+
  coord_cartesian(xlim = c(0,1))
#### f(Large) ####
plot.Large <-
  ggplot()+
  geom_line(data = posts.zoops$f$HDI95,
            aes(x = Large, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 0.5, size = 1,
            position = position_dodgev(height = 80))+
  geom_line(data = posts.zoops$f$HDI90,
            aes(x = Large, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 0.7, size = 1.5,
            position = position_dodgev(height = 80))+
  geom_line(data = posts.zoops$f$HDI75,
            aes(x = Large, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 0.9, size = 2,
            position = position_dodgev(height = 80))+
  geom_line(data = posts.zoops$f$HDI50,
            aes(x = Large, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 1, size = 3,
            position = position_dodgev(height = 80))+
  geom_point(data = posts.zoops$f$mode,
             aes(x = Large, y = Depth, group = interaction(Depth, Size), fill = Size),
             size = 3, shape = 22,
             position = position_dodgev(height = 80))+
  scale_y_reverse(breaks = c(0,100,200,300,400,500,750,1000)) + 
  scale_x_continuous(breaks = c(0,0.50,1))+
  coord_cartesian(xlim = c(0,1))
#### f(Small) ####
plot.Small <-
  ggplot()+
  geom_line(data = posts.zoops$f$HDI95,
            aes(x = Small, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 0.5, size = 1,
            position = position_dodgev(height = 80))+
  geom_line(data = posts.zoops$f$HDI90,
            aes(x = Small, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 0.7, size = 1.5,
            position = position_dodgev(height = 80))+
  geom_line(data = posts.zoops$f$HDI75,
            aes(x = Small, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 0.9, size = 2,
            position = position_dodgev(height = 80))+
  geom_line(data = posts.zoops$f$HDI50,
            aes(x = Small, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 1, size = 3,
            position = position_dodgev(height = 80))+
  geom_point(data = posts.zoops$f$mode,
             aes(x = Small, y = Depth, group = interaction(Depth, Size), fill = Size),
             size = 3, shape = 22,
             position = position_dodgev(height = 80))+
  scale_y_reverse(breaks = c(0,100,200,300,400,500,750,1000)) + 
  scale_x_continuous(breaks = c(0,0.50,1))+
  coord_cartesian(xlim = c(0,1))
#### f(Submicron) ####
plot.Submicron <-
  ggplot()+
  geom_line(data = posts.zoops$f$HDI95,
            aes(x = Submicron, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 0.5, size = 1,
            position = position_dodgev(height = 80))+
  geom_line(data = posts.zoops$f$HDI90,
            aes(x = Submicron, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 0.7, size = 1.5,
            position = position_dodgev(height = 80))+
  geom_line(data = posts.zoops$f$HDI75,
            aes(x = Submicron, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 0.9, size = 2,
            position = position_dodgev(height = 80))+
  geom_line(data = posts.zoops$f$HDI50,
            aes(x = Submicron, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 1, size = 3,
            position = position_dodgev(height = 80))+
  geom_point(data = posts.zoops$f$mode,
             aes(x = Submicron, y = Depth, group = interaction(Depth, Size), fill = Size),
             size = 3, shape = 22,
             position = position_dodgev(height = 80))+
  scale_y_reverse(breaks = c(0,100,200,300,400,500,750,1000)) + 
  scale_x_continuous(breaks = c(0,0.50,1))+
  coord_cartesian(xlim = c(0,1))
#### f(Small+Sub) ####
plot.SmallSub <-
  ggplot()+
  geom_line(data = posts.zoops$f$HDI95,
            aes(x = SmallSub, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 0.5, size = 1,
            position = position_dodgev(height = 80))+
  geom_line(data = posts.zoops$f$HDI90,
            aes(x = SmallSub, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 0.7, size = 1.5,
            position = position_dodgev(height = 80))+
  geom_line(data = posts.zoops$f$HDI75,
            aes(x = SmallSub, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 0.9, size = 2,
            position = position_dodgev(height = 80))+
  geom_line(data = posts.zoops$f$HDI50,
            aes(x = SmallSub, y = Depth, group = interaction(Depth, Size), color = Size),
            alpha = 1, size = 3,
            position = position_dodgev(height = 80))+
  geom_point(data = posts.zoops$f$mode,
             aes(x = SmallSub, y = Depth, group = interaction(Depth, Size), fill = Size),
             size = 3, shape = 22,
             position = position_dodgev(height = 80))+
  scale_y_reverse(breaks = c(0,100,200,300,400,500,750,1000)) + 
  scale_x_continuous(breaks = c(0,0.50,1))+ xlab("Small + Submicron")+
  coord_cartesian(xlim = c(0,1))


ggarrange(plot.Surface,
          plot.Large + no.y.axis,
          plot.Small + no.y.axis,
          plot.Submicron + no.y.axis,
          nrow=1, ncol=4, widths = c(1.25,1,1,1), common.legend = TRUE, legend="top")

ggarrange(plot.Surface,
          plot.Large + no.y.axis,
          plot.SmallSub + no.y.axis,
          nrow=1, ncol=3, widths = c(1.18,1,1), common.legend = TRUE, legend="top")

#### Let's try a different style plot ####
plot.bySize <-
  ggplot()+
  geom_line(data = posts.zoops.long$f$HDI95,
            aes(x = f, y = Depth, 
                group = interaction(Depth, Source), color = Source),
            alpha = 0.5, size = 1,
            position = position_dodgev(height = 80))+
  geom_line(data = posts.zoops.long$f$HDI90,
            aes(x = f, y = Depth, 
                group = interaction(Depth, Source), color = Source),
            alpha = 0.7, size = 1.5,
            position = position_dodgev(height = 80))+
  geom_line(data = posts.zoops.long$f$HDI75,
            aes(x = f, y = Depth, 
                group = interaction(Depth, Source), color = Source),
            alpha = 0.9, size = 2,
            position = position_dodgev(height = 80))+
  geom_line(data = posts.zoops.long$f$HDI50,
            aes(x = f, y = Depth, 
                group = interaction(Depth, Source), color = Source),
            alpha = 1, size = 3,
            position = position_dodgev(height = 80))+
  geom_point(data = posts.zoops.long$f$mode,
             aes(x = f, y = Depth, 
                 group = interaction(Depth, Source), fill = Source),
             size = 2.5, shape = 22,
             position = position_dodgev(height = 80))+
  ylab("Depth (m)")+xlab("f(Source)")+
  labs(fill = "Source")+
  scale_y_reverse(breaks = c(0,100,200,300,400,500,750,1000)) + 
  scale_x_continuous(breaks = c(0,0.50,1))+
  coord_cartesian(xlim = c(0,1))+
  facet_wrap(~Size, nrow=1)

plot.bySize


```

```{r posterior_f_colplots, eval=FALSE, dpi=300, fig.asp=0.5, fig.width=8.5}
#### 0.2-0.5 mm zooplankton ####
plot.p2p5 <-
  ggplot()+
  geom_col(data = subset(posts.zoops.long$f$mean, Size=="0.2-0.5 mm"),
           aes(y=f, x=Depth, fill = Source),
           position = position_fill(), width = 80)+
  scale_x_reverse(breaks = c(200,300,400,500,750,1000), limits = c(1000,200)) + ylab("0.2-0.5 mm") +
  scale_y_continuous(breaks = c(0,0.50,1), limits = c(0,NA))+
  coord_flip()
plot.12 <-
  ggplot()+
  geom_col(data = subset(posts.zoops.long$f$mean, Size=="1-2 mm"),
           aes(y=f, x=Depth, fill = Source),
           position = position_fill(), width = 80)+
  scale_x_reverse(breaks = c(200,300,400,500,750,1000), limits = c(1000,200)) + ylab("1-2 mm") +
  scale_y_continuous(breaks = c(0,0.50,1), limits = c(0,NA))+
  coord_flip()
plot.25 <-
  ggplot()+
  geom_col(data = subset(posts.zoops.long$f$mean, Size=="2-5 mm"),
           aes(y=f, x=Depth, fill = Source),
           position = position_fill(), width = 80)+
  scale_x_reverse(breaks = c(200,300,400,500,750,1000), limits = c(1000,200)) + ylab("2-5 mm") +
  scale_y_continuous(breaks = c(0,0.50,1), limits = c(0,NA))+
  coord_flip()
plot.5 <-
  ggplot()+
  geom_col(data = subset(posts.zoops.long$f$mean, Size==">5 mm"),
           aes(y=f, x=Depth, fill = Source),
           position = position_fill(), width = 80)+
  scale_x_reverse(breaks = c(200,300,400,500,750,1000), limits = c(1000,200)) + ylab(">5 mm") +
  scale_y_continuous(breaks = c(0,0.50,1), limits = c(0,NA))+
  coord_flip()


ggarrange(plot.p2p5,
          plot.12 + no.y.axis,
          plot.25 + no.y.axis,
          plot.5 + no.y.axis,
          nrow=1, ncol=4, widths = c(1.25,1,1,1), common.legend = TRUE, legend="top")

```

# Comparing with other analyses

What we'd like to do now is use the FWM posterior to compare the raw zooplankton SAA $\dNSAA$ values to those that have been adjusted for trophic discrimination.

```{r depth-profile-comparisons}

## Subsetting to include only data from OSP
data.papa = Data_all[as.logical(apply(!is.na(Data_all[tracers]), 1, prod)),]
## Setting factor levels
data.papa$Size[data.papa$Size == "1-5 μm"] <- "1-6 μm"
data.papa$Size[data.papa$Size == "1-5 μm"] <- "1-6 μm"
data.papa$Size <- factor(data.papa$Size, levels = c("0.3-1 μm","1-6 μm", "6-51 μm", ">51 μm", "Trap", "0.2-0.5 mm", "1-2 mm", "2-5 mm", ">5 mm"))
data.papa$Type <- factor(data.papa$Type, levels = c('Particle','Trap','NBST','Zooplankton', 'Chaetognath', 'Neocalanus', 'Metridia', 'Radiolarian'))
data.papa$d15NSAA <- rowMeans(data.papa[c("d15NSer","d15NGly","d15NPhe","d15NLys")])
data.papa$SDd15NSAA <- apply(data.papa[c("SDd15NSer","SDd15NGly","SDd15NPhe","SDd15NLys")], FUN = SDmean, MARGIN = 1)
## Subsetting further into zooplankton and particle data sets
data.papa.parts = subset(data.papa, Type == 'Particle')
data.papa.zoops =  subset(data.papa, (Type == 'Zooplankton' & Event == "Night"))# | Type == 'Metridia' | Type == 'Neocalanus' | Type == 'Chaetognath' | Type == 'Radiolarian'))
data.papa.traps = subset(data.papa, Type == 'Trap')

## Now were going to average particle d15N SAA data within depth bins so it can be compared with zoops (bins: 1-50, 51-100, 101-150, 151-200, 201-300, 301-400, 401-500)
maxdepths = c(50,100,150,205,300,400,500)
mindepths = c(1,51,101,151,206,301,401,501)
avgdepths = c(25,75,125,175,250,350,450)
DF = data.papa.parts[,c('Depth','Size','d15NSAA','SDd15NSAA','d15NPhe','SDd15NPhe')]
data.avg.parts = data.papa.parts %>%
  group_by(Depth = cut(DF$Depth, breaks=mindepths, labels = avgdepths), Size, .drop = TRUE) %>%
  summarise(d15NSAA = mean(d15NSAA), 
            SDd15NSAA = max(sd(d15NSAA),SDmean(SDd15NSAA), na.rm = TRUE),
            d15NPhe = mean(d15NPhe), 
            SDd15NPhe = max(sd(d15NPhe),SDmean(SDd15NPhe), na.rm = TRUE))
data.avg.parts$Depth = as.numeric(as.character(data.avg.parts$Depth))

# next we'll grab the data for each layer of the plot
data.plots.parts <- data.avg.parts
data.plots.traps <- data.papa.traps
data.plots.zoops <- data.papa.zoops
data.plots.zoops$facetSize = data.plots.zoops$Size

# We'll grab the MCMC posterior d15N values for the base of the zooplankton food web
data.plots.zoops.post <- posts.zoops$base$mode
data.plots.zoops.post$d15NSAA <- rowMeans(data.plots.zoops.post[c("d15NSer","d15NGly","d15NPhe","d15NLys")])
data.plots.zoops.post$facetSize = factor(data.plots.zoops.post$Size, levels = c("0.2-0.5 mm", "1-2 mm", "2-5 mm", ">5 mm"))
data.plots.zoops.HDI <- posts.zoops$base$HDI95
data.plots.zoops.HDI$HDI95SAA <- rowMeans(posts.zoops$base$HDI95[c("d15NSer","d15NGly","d15NPhe","d15NLys")])
data.plots.zoops.HDI$HDI90SAA <- rowMeans(posts.zoops$base$HDI90[c("d15NSer","d15NGly","d15NPhe","d15NLys")])
data.plots.zoops.HDI$HDI75SAA <- rowMeans(posts.zoops$base$HDI75[c("d15NSer","d15NGly","d15NPhe","d15NLys")])
data.plots.zoops.HDI$HDI50SAA <- rowMeans(posts.zoops$base$HDI50[c("d15NSer","d15NGly","d15NPhe","d15NLys")])
data.plots.zoops.HDI$facetSize = factor(data.plots.zoops.HDI$Size, levels = c("0.2-0.5 mm", "1-2 mm", "2-5 mm", ">5 mm"))

plot.parts_zoops =
  ggplot(data = data.plots.parts,
         aes(x = d15NSAA, y = Depth, color = Size, group = Size))+labs(color = "Particles")+
  scale_y_reverse(breaks = c(0,100,200,300,400,500,750,1000), minor_breaks = c(50,150)) + 
  xlab(expression(delta^{15}*"N"[SAA]*" (\u2030)")) + ylab('Depth (m)') + coord_cartesian(ylim=c(1000,0), xlim=c(-2.5,6.5))+
  #geom_point(size = 2) + 
  geom_path(size = 1, alpha=0.8)+
  geom_ribbon(aes(fill = Size,  xmin = d15NSAA-SDd15NSAA, xmax = d15NSAA+SDd15NSAA), alpha = 0.50, color = NA)+labs(fill = "Particles")+
  
  geom_point(data = data.plots.traps, 
             aes(x = d15NSAA, y = Depth, xmin = d15NSAA-SDd15NSAA, xmax = d15NSAA+SDd15NSAA, size = Type), 
             color = "black", shape = 6, stroke = 0.75, alpha=0.6)+scale_shape_discrete(solid = TRUE)+
  geom_errorbarh(data = data.plots.traps, 
                 aes(x = d15NSAA, xmin = d15NSAA-SDd15NSAA, xmax = d15NSAA+SDd15NSAA), 
                 height = 1, size = 0.5, linetype = 1, color = 'black', alpha=0.6)+labs(size = 'Traps')+
  
  geom_point(data = data.plots.zoops, 
             aes(x = d15NSAA, y = Depth, xmin = d15NSAA-SDd15NSAA, xmax = d15NSAA+SDd15NSAA, shape = "Raw Data", group = Type), 
             color = "black", size = 2, stroke = 0.75)+labs(shape = "Zooplankton")+scale_shape_discrete(solid = TRUE)+
  geom_path(data = data.plots.zoops, 
            aes(x = d15NSAA, xmin = d15NSAA-SDd15NSAA, xmax = d15NSAA+SDd15NSAA, y = Depth, group = interaction(Size,Type)), 
            color = "black", size = 1, linetype = "solid", alpha = 0.20)+
  geom_errorbarh(data = data.plots.zoops, 
                 aes(x = d15NSAA, xmin = d15NSAA-SDd15NSAA, xmax = d15NSAA+SDd15NSAA), height = 1, size = 0.5, linetype = 1, color = 'black')+
  
  geom_point(data = data.plots.zoops.post,
             aes(x = d15NSAA, y = Depth, shape = "Model Posterior", group = Type),
             color = "black", size = 2, stroke = 0.75)+labs(shape = "Zooplankton")+scale_shape_discrete(solid = TRUE)+
  geom_path(data = data.plots.zoops.post, 
            aes(x = d15NSAA, y = Depth), 
            color = "black", size = 1, linetype = "solid", alpha = 0.20)+
  geom_line(data = data.plots.zoops.HDI,
            aes(x = HDI95SAA, y = Depth, group = Depth),
            alpha = 0.5, size = 1, color="black")+
  geom_line(data = data.plots.zoops.HDI,
            aes(x = HDI90SAA, y = Depth, group = Depth),
            alpha = 0.7, size = 1.5, color="black")+
  geom_line(data = data.plots.zoops.HDI,
            aes(x = HDI75SAA, y = Depth, group = Depth),
            alpha = 0.9, size = 2, color="black")+
  geom_line(data = data.plots.zoops.HDI,
            aes(x = HDI50SAA, y = Depth, group = Depth),
            alpha = 1, size = 3, color="black")+
  # geom_errorbarh(data = data.plots.zoops, 
  #                aes(x = d15NSAA, xmin = d15NSAA-SDd15NSAA, xmax = d15NSAA+SDd15NSAA), height = 1, size = 0.5, linetype = 1, color = 'black')+
  
  scale_color_manual(values = c(hcl(15,100,65),hcl(125,100,65),hcl(205,100,60),hcl(285,100,65)))+
  scale_fill_manual(values = c(hcl(15,100,65),hcl(125,100,65),hcl(205,100,60),hcl(285,100,65)))+
  scale_shape_manual(values = c("square","circle"))+
  facet_wrap(~ facetSize, nrow=1)+
  theme_light()

plot.parts_zoops



```



The last things we want to do here is export out mixing model results to a viewable table and a .xlsx file.

```{r export-results, eval=TRUE}
Data.parts <- data.papa.parts[c(variables,
                               "d15NSer","d15NGly","d15NPhe","d15NLys",
                               "SDd15NSer","SDd15NGly","SDd15NPhe","SDd15NLys",
                               "d15NSAA","SDd15NSAA")]

save(posts.global, posts.global.long, 
     posts.zoops, posts.zoops.long, 
     Data_all, data.avg.parts,
     file = "OSP_all_posteriors.RData")


```



