---
title: "Organic Matter Supply Model: Assessing model performance using simulated data from Station Papa"
author: "Connor Shea"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
output: 
  #html_document: 
  bookdown::html_document2:  
    self-contained: yes
    theme: cerulean #paper #cosmo #journal #readable
    toc: true
    smooth_scroll: true
    toc_depth: 3
    toc_float: true
    number_sections: true
    fig_caption: yes
    code_folding: hide
bibliography: Utilities/MesoPelaZooAA.bib
csl: Utilities/LnO.csl
link-citations: yes
---

```{r setup, echo=FALSE, warning=FALSE}
## This chunk sets up a working directory, loads packages, defines a couple functions, and sets global chunk options for the .Rmd document

# clean up
rm(list=ls()) 

# fresh start? If FALSE (select 2 in hard bracket), will only rerun a chunk if 
# changes are detected within the text of that chunk.
rmCache <- c(TRUE, FALSE)[2] 
tfn <- knitr::current_input()              # name of this file
tfn <- substr(tfn, 1, nchar(tfn)-4)        # Remove the ".Rmd"
tfn_cache <- paste0("Caches/", tfn, "_cache")         # Append "_cache" to it
tfn_figures <- paste0("Figures/", tfn, "_figures")         # Append "_figures" to it
if (rmCache) {
  if (file.exists(tfn_cache))                # If the cache exists...
    unlink(tfn_cache, recursive=TRUE)        # ...delete it.
}

# load packages quietly
shhh <- suppressPackageStartupMessages # It's a library, so shhh!
want <- c(
  "knitr",
  "readxl",          # For reading Excel files
  "MASS",            # Statistical functions (e.g., LDA)
  "vegan",           # Ecology statistics
  "FactoMineR",      # PCA and utilities
  "factoextra",      # Extra tools for FactoMineR
  "runjags",         # Bayesian MCMC with JAGS
  "TruncatedDistributions", # Truncated probability distributions
  "coda",            # MCMC diagnostics
  "DT",              # Sortable tables
  "openxlsx",        # Excel writing
  "compositions",    # Compositional data analysis
  "kableExtra",      # Enhanced tables
  "zeallot",         # Multiple assignment
  "magrittr",        # Pipe operator
  "DirichletReg",    # Dirichlet regression
  "Ternary",         # Ternary plots
  "png",             # PNG support
  "ggplot2",         # Plotting
  "ggpubr",          # Publication-ready plots
  "ggstance",        # Vertical dodging
  "ggtern",          # Ternary plots in ggplot2
  "ggforce",         # Extra plotting features
  "plotly",          # Interactive plots
  "gridExtra",       # Grid layouts
  "graphics",        # Base graphics
  "reshape2"         # Data reshaping
)
for (pkg in want) shhh(library(pkg, character.only=TRUE))

# set some chunk options
gr <- (1+sqrt(5))/2 # golden ratio, for figures
opts_chunk$set(comment="  ",
               fig.asp=0.9/gr,       # <--- gr used here
               fig.align="center",
               fig.width=5,
               out.width="95%",
               dpi=96, # set to 300 for important figures
               dev="png", # png, svg, pdf, jpg, tiff
               #echo=FALSE,
               cache=c(TRUE, FALSE)[1], 
               cache.path = paste0(tfn_cache,"/"),
               fig.path = paste0(tfn_figures,"/"),
               eval.after="fig.cap", # for dynamic captions
               collapse=TRUE
               )

## a couple of lines we need to run every time we knit
# setting the ggplot theme
theme_set(theme_classic2()+
            theme(panel.grid.major.x = element_line(colour = "grey95"),
                  panel.grid.major.y = element_line(colour = "grey95")))
# defining a ggplot object to remove the x axis
no.x.axis <- theme(axis.title.x=element_blank(),
                   axis.text.x=element_blank(),
                   axis.ticks.x=element_blank())
# defining a ggplot object to remove the y axis
no.y.axis <- theme(axis.title.y=element_blank(),
                   axis.text.y=element_blank(),
                   axis.ticks.y=element_blank())

# Load custom functions (edit paths if relocated)
source("Utilities/DBDA2E-utilities.R", local = c(TRUE, FALSE)[1])  # Kruschke’s utilities
source("Functions/calcSDs.R")         # SDmean() and SDsum()
source("Functions/Post-Mode.R")       # post.mode()
source("Functions/SplitViolin.R")     # geom_split_violin()
source("Functions/OMSM_Gen_Model.R")  # Bayesian model generation
source("Functions/Sim_Zoop.R")        # Zooplankton simulation
source("Functions/Sim_Zoop_RealPhe.R") # Zooplankton simulation with Phe adjustment
source("Functions/OMSM_Global_Extract.R") # Global parameter extraction
source("Functions/OMSM_Zoop_Extract.R")   # Zooplankton parameter extraction
```  

<!-- The following commands provide a shorthand for common symbols when used in math mode. -->
\input{}

\newcommand{\um}{\ \mu \mathrm{ m}}
\newcommand{\mm}{\mathrm{\ mm}}
\newcommand{\m}{\mathrm{\ m}}
\newcommand{\N}{\mathrm{^{15}\text{N}}}
\newcommand{\dN}{\mathrm{\delta^{15}\text{N}}}
\newcommand{\dNAA}{\mathrm{\delta^{15}\text{N}_\text{AA}}}
\newcommand{\dNSAA}{\mathrm{\delta^{15}\text{N}_\text{SAA}}}
\newcommand{\dNTAA}{\mathrm{\delta^{15}\text{N}_\text{TAA}}}
\newcommand{\dNtr}{\mathrm{\delta^{15}\text{N}_\text{tr}}}
\newcommand{\dNsrc}{\mathrm{\delta^{15}\text{N}_\text{src}}}
\newcommand{\dNphe}{\mathrm{\delta^{15}N_{phe}}}
\newcommand{\dNthr}{\mathrm{\delta^{15}N_{thr}}}
\newcommand{\dNala}{\mathrm{\delta^{15}N_{ala}}}
\newcommand{\dNglx}{\mathrm{\delta^{15}N_{glx}}}
\newcommand{\dNThrPhe}{\mathrm{\delta^{15}N_{thr-phe}}}
\newcommand{\dNAlaPhe}{\mathrm{\delta^{15}N_{ala-phe}}}
\newcommand{\dNglxphe}{\mathrm{\delta^{15}N_{glx-phe}}}
\newcommand{\DN}{\mathrm{\Delta^{15}\text{N}}}
\newcommand{\DNAA}{\mathrm{\Delta^{15}\text{N}_\text{AA}}}
\newcommand{\C}{\mathrm{^{13}\text{C}}}
\newcommand{\dC}{\mathrm{\delta^{13}\text{C}}}
\newcommand{\dCAA}{\mathrm{\delta^{13}\text{C}_\text{AA}}}
\newcommand{\dCEAA}{\mathrm{\delta^{13}\text{C}_\text{EAA}}}
\newcommand{\dCNAA}{\mathrm{\delta^{13}\text{C}_\text{NAA}}}
\newcommand{\permil}{‰}
\newcommand{\degree}{°}
\newcommand{\TP}{\mathrm{TP}}
\newcommand{\TPala}{\mathrm{TP_{ala-phe}}}
\newcommand{\TPglx}{\mathrm{TP_{glx-phe}}}
\newcommand{\TPts}{\mathrm{TP_{tr-src}}}
\newcommand{\dTP}{\mathrm{\Delta TP_{ala-glx}}}

# Summary {-}  
The purpose of this notebook is to assess isotopic separation of organic matter sources in a particular setting, and then test the ability of an AA-CSIA-based food web model to diagnose the relative importance of those sources to a food web or higher order consumer. The results here are diagnostic of the model's efficacy in a specific setting, and should be used to inform the interpretation of the food web model's output when applied to natural samples of consumers from that same environment.

This notebook is composed of the following sections:

 ### Sections:
1. **Setup**: Input data and parameters.
2. **Source Separation**: Multivariate analysis of source distinction.
3. **Data Simulation**: Generate synthetic zooplankton data.
4. **Model Execution**: Fit the Bayesian model and run diagnostics.
5. **Model Assessment**: Compare outputs to simulation parameters.

# Setup {-}

In the first few chunks, the user should enter all of the basic information that the model code will need to proceed with analysis.

The first chunk identifies tracers to be included in the model and how to treat them.

```{r identifying_tracers}
################################################################################
## IDENTIFYING SOURCE AND DESCRIPTIVE VARIABLES ##

# Indicate the name of the column describing the organic matter source to which each sample belongs.
# This column will be renamed to "Group"
Source.Variable <- "Group"
# Indicate the names representing each possible source of organic matter to the food web/consumer.
# The order of this vector will describe the order these groups are referenced in figures.
# The model can accomodate 2-6 organic matter sources, but will need to be modified to accomodate more.
Sources <- c("Surface","Large","Small")
# Indicate the names of all the consumer types also present in this column.
# This could be a generic identifier like "consumer" but should not be left empty here or in the spreadsheet
Consumers <- c("Mixed","Taxa")

# List the name of any additional variables that should be stored for analysis.
# The data in these columns must be complete for all samples.
Descriptive.Variables <- c("Location","Epoch","Event","Size","Sizecat","Depth","Type")


################################################################################
## SPECIFYING TRACERS TO BE USED IN MODEL ##
# Tracer names should match column names in the data spreadsheet
# We'll store them in two lists
Tracers <- list()
SDTracers <- list()

# TRACERS FOR TROPHIC EQUATIONS
# These tracers will not be used to solve mixing equations
# FWL: Specify the name of the tracer that will estimate the full food web length
Tracers$FWL <- 
  c("d15NPro")
SDTracers$FWL <- 
  c("SDd15NPro")
# MTS: Specify the name of the tracer that will estimate the number of metazoan trophic steps
Tracers$MTS <- 
  c("d15NGlx")
SDTracers$MTS <- 
  c("SDd15NGlx")

# TRACERS FOR MIXING EQUATIONS
# Tracers for trophic equations must not be included in this list
Tracers$mix <-
  c(
    # "d15NAla",
    # # "d15NAsx",
    # # "d13CLeu",
    # # "d13CIle",
    # # "d15NPro",
    "d15NThr",
    # # "d15NSer",
    # # "d15NGly",
    "d15NLys",
    "d15NPhe"
  )
SDTracers$mix <-
  c(
    # "SDd15NAla",
    # # "SDd15NAsx",
    # # "SDd13CLeu",
    # # "SDd13CIle",
    # # "SDd15NPro",
    "SDd15NThr",
    # # "SDd15NSer",
    # # "SDd15NGly",
    "SDd15NLys",
    "SDd15NPhe"
  )

# Specify the names for all tracers with constant trophic discrimination  and their uncertainty(i.e., TDF(protozoan) = TDF(metazoan))
Tracers$constTDF <- 
  c(
    # "d15NPhe",
    "d15NAla", 
    "d15NPro", 
    "d15NSer", 
    "d15NGly", 
    "d15NLys", 
    "d15NThr"
  )
SDTracers$constTDF <- 
  c(
    # "SDd15NPhe",
    "SDd15NAla", 
    "SDd15NPro", 
    "SDd15NSer", 
    "SDd15NGly", 
    "SDd15NLys", 
    "SDd15NThr"
  )

# Specify the names for all tracers with variable trophic discrimination  and their uncertainty(i.e., TDF(protozoan) != TDF(metazoan))
Tracers$varTDF <- 
  c(
    "d15NGlx", 
    "d15NAsx"
  )
SDTracers$varTDF <- 
  c(
    "SDd15NGlx", 
    "SDd15NAsx"
  )

# Specify the names for all conservative tracers and their uncertainty (i.e., no trophic discrimination is expected)
Tracers$non <- 
  c(
    "d15NPhe",
    "d13CThr", 
    "d13CVal", 
    "d13CLeu", 
    "d13CIle", 
    "d13CPhe"
  )
SDTracers$non <- 
  c(
    "SDd15NPhe",
    "SDd13CThr", 
    "SDd13CVal", 
    "SDd13CLeu", 
    "SDd13CIle", 
    "SDd13CPhe"
  )

# Is there a subset of these tracers that should be mean normalized?
meannorm <- TRUE
# If TRUE, which should be mean normalized?
meannorm.which <- 
  c(
    "d13CThr", 
    "d13CVal", 
    "d13CLeu", 
    "d13CIle"
  )
SDmeannorm.which <- 
  c(
    "SDd13CThr", 
    "SDd13CVal", 
    "SDd13CLeu", 
    "SDd13CIle"
  )

################################################################################
## Making some master lists of tracers - no changes necessary here ##
# All tracers
Tracers$all <- 
  c(
    Tracers$constTDF,
    Tracers$varTDF,
    Tracers$non
  )
SDTracers$all <- 
  c(
    SDTracers$constTDF,
    SDTracers$varTDF,
    SDTracers$non
  )
# Tracers that fractionate
Tracers$frac <- 
  c(
    Tracers$constTDF,
    Tracers$varTDF
  )
SDTracers$frac <- 
  c(
    SDTracers$constTDF,
    SDTracers$varTDF
  )
# Ensuring that trophic tracers are not also mixing tracers
if(sum(Tracers$mix %in% c(Tracers$FWL,Tracers$MTS)) > 0) {
  stop("Trophic tracers should not be included in the list of mixing tracers.")
}
# Tracers that fractionate and will be used to fit the model
Tracers$mixfrac <- 
  Tracers$mix[which(Tracers$mix %in% Tracers$frac)]
SDTracers$mixfrac <- 
  SDTracers$mix[which(SDTracers$mix %in% SDTracers$frac)]
# we also need to bypass all multivariate analyses if <3 tracers
runMV <- TRUE
if(length(Tracers$mix) < 3){
  runMV <- FALSE
}

################################################################################
## SPECIFYING CHOICES FOR TDF(PROTOZOAN) AND TDF(METAZOAN) ##
# Note: default values are those used in Shea et al. (in prep)

## What TDFs and SDs should be used to describe amino acid δ15N fractionation in metazoans?
## Note that these TDFs should NOT be normalized to any source amino acid.
TDF_meta <- data.frame("d15NAla" = 6.3, "SDd15NAla" = 2.6,
                       "d15NGly" = 2.9, "SDd15NGly" = 3.1,
                       "d15NThr" =-2.1, "SDd15NThr" = 0.9,
                       "d15NSer" = 2.6, "SDd15NSer" = 3.2,
                       "d15NVal" = 4.4, "SDd15NVal" = 2.6,
                       "d15NLeu" = 5.6, "SDd15NLeu" = 2.4,
                       "d15NIle" = 5.5, "SDd15NIle" = 2.4,
                       "d15NPro" = 5.8, "SDd15NPro" = 1.7,
                       "d15NAsx" = 5.7, "SDd15NAsx" = 1.9,
                       "d15NMet" = 1.6, "SDd15NMet" = 2.6,
                       "d15NGlx" = 8.0, "SDd15NGlx" = 1.7,
                       "d15NPhe" = 0.3, "SDd15NPhe" = 0.5,
                       "d15NTyr" = NA , "SDd15NTyr" = NA,
                       "d15NLys" = 1.2, "SDd15NLys" = 1.2)

## What TDFs and SDs should be used to describe amino acid δ15N fractionation in protozoans?
# Note that these TDFs should NOT be normalized to any source amino acid.
TDF_proto = data.frame("d15NAla" = 6.3, "SDd15NAla" = 2.6,
                       "d15NGly" = 2.9, "SDd15NGly" = 3.1,
                       "d15NThr" =-2.1, "SDd15NThr" = 1.0,
                       "d15NSer" = 2.6, "SDd15NSer" = 3.2,
                       "d15NVal" = 0.7, "SDd15NVal" = 1.6,
                       "d15NLeu" = 1.4, "SDd15NLeu" = 0.6,
                       "d15NIle" =-0.5, "SDd15NIle" = 2.7,
                       "d15NPro" = 5.8, "SDd15NPro" = 1.7,
                       "d15NAsx" = 0.8, "SDd15NAsx" = 1.4,
                       "d15NMet" = NA , "SDd15NMet" = NA ,
                       "d15NGlx" = 0.5, "SDd15NGlx" = 1.0,
                       "d15NPhe" = 0.3, "SDd15NPhe" = 0.5,
                       "d15NTyr" = NA , "SDd15NTyr" = NA,
                       "d15NLys" = 1.2, "SDd15NLys" = 1.2)

# Define the Order you would like tracers referenced in, if any
Order <- c("d15NGlx", "d15NAsx", "d15NAla", "d15NIle", "d15NLeu", "d15NPro", "d15NVal", 
           "d15NGly", "d15NSer", "d15NLys", "d15NPhe", "d15NThr", "SAA",
           "d13CGlx", "d13CAsx", "d13CAla", "d13CIle", "d13CLeu", "d13CPro", "d13CVal", 
           "d13CGly", "d13CSer", "d13CLys", "d13CPhe", "d13CThr", "EAA")
SDOrder <- c("SDd15NGlx", "SDd15NAsx", "SDd15NAla", "SDd15NIle", "SDd15NLeu", "SDd15NPro", "SDd15NVal", 
             "SDd15NGly", "SDd15NSer", "SDd15NLys", "SDd15NPhe", "SDd15NThr", "SDSAA",
             "SDd13CGlx", "SDd13CAsx", "SDd13CAla", "SDd13CIle", "SDd13CLeu", "SDd13CPro", "SDd13CVal", 
             "SDd13CGly", "SDd13CSer", "SDd13CLys", "SDd13CPhe", "SDd13CThr", "SDEAA")
# If all tracers used aren't specified in the Order vector then it will be redefined
if(length(which(Order %in% Tracers$all))<length(Tracers$all)){
  Order <- Tracers$all
  SDOrder <- SDTracers$all
}

```

The next thing we will do is import the data. All of the data for organic matter sources and consumers should be contained in one Excel spreadsheet. Each column will be either a descriptive variable or tracer. The first row will include all variable/tracer names and each subsequent row will be a sample. The tracer data and descriptive data need to be complete for every sample included in this analysis. Any sample with an empty cell will be dropped.

```{r Import_Data, eval=TRUE, fig.asp=0.6, out.width="100%"}

## All data should be stored in one, single .xlsx file. 

## Columns containing tracer values, uncertainties, and descriptive variables should match those defined in the chunk above.

################################################################################
## IMPORTING DATA ##
# Define the location of .xlsx file, and sheet name if multiple sheets are  present.
Data.all <- read_excel("Data/AA-CSIA_OSP.xlsx",
                       sheet = "combined")[
                         c(Source.Variable,Descriptive.Variables,Tracers$all,SDTracers$all)
                         ]
colnames(Data.all)[colnames(Data.all)==Source.Variable] <- "Group"
variables <- c("Group", Descriptive.Variables)
# Defining the preferred Order in which to reference organic matter sources
Data.all$Group <- factor(Data.all$Group, levels = c(Sources,Consumers))
# To define the order that specific descriptive variables should be referenced, adapt the below example.
# Data.all["Size"] <- factor(Data.all[["Size"]], levels = c(
#   c("0.3-1 μm", "1-5 μm", "1-6 μm", "6-51 μm", ">51 μm", "Sediment Trap",
#   "0.2-0.5 mm", "0.5-1.0 mm", "1-2 mm", "2-5 mm", ">5 mm")
# ))
```

Next we will mean normalize the data for a subset of tracers, based on the information given above. This is particularly useful if essential amino acid $\d13C$ values are to be included in the model. Note that the mean value of mean normalized tracers can be added as an additional tracer if that argument is made "TRUE" below.

```{r mean_normalization}
Data.all.orig <- Data.all
# If mean normalizing some of the data
if(meannorm == TRUE) {
  # Calculating the mean value of those AAs in each sample
  MN <- rowMeans(Data.all[meannorm.which])
  SD <- c()
  for (i in 1:nrow(Data.all)) {
    SD <- append(SD, SDmean(Data.all.orig[i,SDmeannorm.which]))
  }
  # Subtracting that from the EAA δ13C values for each sample
  # and replacing raw δ13C values in main data frame with mean normalized ones
  Data.all[meannorm.which] <- sweep(Data.all[meannorm.which], 1, MN, "-")
  # Can include the mean values as an additional tracer
  include_meannorm_mean <- FALSE # make true to include mean values as separate tracer
  if(include_meannorm_mean == TRUE){
    Data.all$meannorm_mean <- MN
    Data.all$SDmeannorm_mean <- SD
    Tracers$all <- append(Tracers$all, "EAA")
    SDTracers$all <- append(SDTracers$all, "SDEAA")
  }
}

# we'll also need the mean values of tracers in organic matter sources later...
# first calculating the mean tracer value for each organic matter source group
src.mn <- 
  aggregate(Data.all[Tracers$all], # aggregate source data
            by=list(Group = Data.all[["Group"]]), # by organic matter source group
            FUN = mean, na.rm=TRUE)[-1] # taking a mean
# and the SD
# we will calculate the standard deviation within each population
src.SD <- 
  aggregate(Data.all[Tracers$all], # aggregate source data
            by=list(Group = Data.all[["Group"]]), # by organic matter source group
            FUN = sd, na.rm=TRUE)[-1] # calculating SD within the population
```

Now we'll pull out the organic matter source data data as a separate data frame.

```{r Isolating_Sources}

################################################################################
## ISOLATING ORGANIC MATTER SOURCE DATA ##
Data.sources <- subset(Data.all, Type == "Particle" | Type == "Trap")
## FILTERING DATA ##
Data.sources$Group <- factor(NA, levels = Sources)
Data.sources$Group[
  which(Data.sources$Depth < 100 &
        Data.sources$d15NLys < 0.5)
  ] <- "Surface"
Data.sources$Group[
  which(Data.sources$Depth > 190 & 
        (Data.sources$Sizecat == "Large" | Data.sources$Sizecat == "Trap"))
  ] <- "Large"
Data.sources$Group[
  which(Data.sources$Depth > 190 & Data.sources$Sizecat == "Small")
  ] <- "Small"
Data.sources <- subset(Data.sources, !is.na(Group))
# If a sample is missing data it will be removed in this step
Data.sources <- na.omit(Data.sources)

```

# Assessing source separation {-}

First lets visualize the value of each tracer in each organic matter source.

```{r Tracer_Plots_Sources, dpi=300, fig.asp=0.4, fig.width=8.5}
Sources.long <- melt(Data.sources, id.vars=c(variables), measure.vars =c(Tracers$mix),
                     variable.name = "Tracer", value.name = "Value")

# Defining the preferred Order in which to reference Tracers$
Sources.long$Tracer <- factor(Sources.long$Tracer, levels = Order)

AA_plots <-
  ggplot(Sources.long, aes(x = Tracer, y = Value, color = Group, group=Group))+
  geom_point(alpha=0.4, position = position_dodge(width = 0.8))+
  labs(color="Organic Matter Source", shape="Food Web Base", fill="Zooplankton Samples")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.3, hjust=1))
AA_plots
```

Next, to visualize the between group patterns in the data we will do some multivariate analyses. We'll start by carrying out a PCA. This should give us a decent of idea of what kind of if between-group separation is a major component of variation in this data set. It will also help us visualize which tracers are driving separation between certain organic matter sources and which are providing redundant information.

```{r PCA_sources, dpi=300, fig.asp=0.6, out.width="90%", eval=runMV}
# Fitting PCA and adding Sample and Type as a supplemental qualitative variable
PCA = PCA(Data.sources[c(variables,Tracers$mix)], scale.unit = FALSE, quali.sup = variables, graph = FALSE)

# ## Uncomment these lines to see some diagnostics of how the PCA ran
# # Plot component variance
# fviz_eig(PCA, addlabels = FALSE, geom = "bar")
# 
# # Print a summary of the PCA results
# summary(PCA)

# Plot PC1&2 results and project variable vectors and print
fviz_pca_biplot(PCA, axes = c(1,2), # axes tell which components to plot
                geom = "point", addEllipses = TRUE, col.ind = Data.sources[["Group"]], col.var = 'grey50', repel=TRUE, # some display settings
                label = c("quali", "var")) # labelling
```

We'll also try fitting an LDA to see if this is can work as a better tool to visualize our mixing space.

```{r LDA_sources, dpi=300, fig.asp=0.8}
if(runMV == TRUE){
ntypes = nlevels(as.factor(Data.sources[["Group"]]))
# fitting the model with leave one out cross validation
LDA.test = lda(Group ~ . ,data = Data.sources[c("Group",Tracers$mix)], CV = TRUE,
               prior = rep(1/ntypes, ntypes))

# ## uncomment these lines to see the results of leave one out cross-validation 
# ## and see some LDA model diagnostics
# print model result
# LDA.train

# # create a table which compares the classification of the LDA model to the actual producer type
# ct.prod.norm <- table(Data.sources[["Group"]], 
#                       LDA.test$class)
# # total percent of samples correctly classified is the sum of the diagonal of this table
# noquote(c('% successfully categorized: ', sum(diag(prop.table(ct.prod.norm))))) #85% effective

# Refitting the model using all of the available training data
LDA.full = lda(Group ~ . ,data = Data.sources[c("Group",Tracers$mix)], CV = FALSE, prior = rep(1/ntypes, ntypes))

## uncomment this line to see a summary of the full LDA
LDA.full

# store locations of training data in LD space for later plotting
pred.train = predict(LDA.full, Data.sources[Tracers$mix])
class.train = data.frame('Type' = Data.sources[["Group"]], pred.train$x)

# Generate biplot with training data only
plot.mix.LD12 = ggplot(data = class.train, 
                       aes(x = LD2, y = LD1, color = Type), size = 2) + 
  geom_point(alpha = 0.3, size=3) + 
  stat_ellipse(type = 't', alpha = 0.6)+
  theme(legend.position = 'none')
if(length(Sources) > 3){
  plot.mix.LD13 = ggplot(data = class.train, 
                         aes(x = LD3, y = LD1, color = Type), size = 2) + 
    geom_point(alpha = 0.3, size=3) +  
    stat_ellipse(type = 't', alpha = 0.6)+
    labs(color = "Training Data")
  grid.arrange(ncol = 2, widths = c(1,1.2), plot.mix.LD12, plot.mix.LD13, top = 'LDA of Organic Matter Sources') + theme(legend.position = 'top')
}else{
  plot.mix.LD12
}
}
```

# Simulating zooplankton data {-}

Next we will simulate some zooplankton data as a way to test the efficacy of the model under different ecological scenarios. We will simulate it using known ecological parameters and the same TDFs that will be supplied to the food web model as a prior. If the organic matter source data provides adequate separation of mixing end member and TDF are well enough constrained relative to the length of the food web expect in wild samples, then the model should return parameters wimilar to those defined in the following chunk.

Note that there are two methods for generating mixing parameters describing the relative contributins of organic matter sources to the base of the food web:

  1. One method will simulate zooplankton whose mixture of organic matter sources is described using a Dirichlet distribution. This can either generate a handful of samples with random reliance on organic matter sources, or samples normally distributed about a point in the n-dimensional mixing space.
  2. The other method will simulate a set of zooplankton samples, with the reliance of each sample on each source of organic matter specifically defined by the user.


```{r SimZoop, eval=TRUE, fig.asp=0.6, out.width="100%", fig.cap=c("Ternary diagram showing the fractional contribution of our three sources (small and large particle and actively transported material) to the base of our simulated zooplankton food web.", "Simulated samples of source material and now zooplankton are plotted with respect to all three tracer $\\dN$ values.", "Simulated samples of source material and now zooplankton are plotted with respect to $\\dNglx$ and $\\dNthr$, both normalized to $\\dNphe$.")}

source("Functions/Sim_Zoop_RealPhe.R")
# source("Functions/Sim_Zoop.R")

## Sim_Zoop_RealPhe uses 0.3‰ trophic discrimination in Phe to simulate zooplankton
## data even though the model will assume it is conservative.
Sim_Zoop_RealPhe( # use this if treating Phe as a conservative tracer in the model
# Sim_Zoop( # use this if treating Phe as a fractionating tracer in the model
    zoops.n = 50,
    disperse = 0.5,
    incr = 0.2,
    PTS = c(0,0.5,1),
    MTS = c(1,1.5,2),
    PTS.sd = 0.5,
    MTS.sd = 0.5,
    TDF_m = TDF_meta[Tracers$frac], # trophic discrimination factors
    TDF_m.sd = TDF_meta[SDTracers$frac], # SD of trophic discrimination factors
    TDF_p = TDF_proto[Tracers$frac], # trophic discrimination factors
    TDF_p.sd = TDF_proto[SDTracers$frac], # SD of trophic discrimination factors
    Sources = Sources,
    Data.sources = Data.sources,
    Tracers = Tracers,
    SDTracers = SDTracers,
    variables = variables,
    Use_Dirichlet = TRUE,
    zoops.f = zoops.f,
    seed = 222
)

```
Let's plot out the tracer values of organic matter sources and zooplankton.

## Plotting Simulated Data {-}
```{r Tracers_Zoops.plots, dpi=300, fig.asp=0.3, fig.width=8}
# Plot tracer values for sources, zooplankton, and food web base.
Zoops.long <- melt(Data.zoops, id.vars = variables, measure.vars = Tracers$mix,
                   variable.name = "Tracer", value.name = "Value")
Base.long <- melt(base.sim, id.vars = variables, measure.vars = Tracers$mix,
                  variable.name = "Tracer", value.name = "Value")
AA_plots <- ggplot(Sources.long) +
  geom_point(aes(x = Tracer, y = Value, color = Group), alpha = 0.4,
             position = position_nudge(x = 0.1)) +
  geom_point(data = Zoops.long, aes(x = Tracer, y = Value, shape = "Zooplankton"),
             color = "black", position = position_nudge(x = -0.1)) +
  geom_point(data = Base.long, aes(x = Tracer, y = Value, shape = "Food Web Base"),
             color = "brown", position = position_nudge(x = 0)) +
  ylab("Value") +
  labs(color = "Organic Matter Source", shape = "Simulated Data") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.3, hjust = 1))

if (runMV) {
  pred.zoops <- predict(LDA.full, Data.zoops)
  class.zoops <- data.frame(Predicted = pred.zoops$class, pred.zoops$x,
                            lapply(Data.zoops[variables], as.character))
  pred.base <- predict(LDA.full, base.sim)
  class.base <- data.frame(Predicted = pred.base$class, pred.base$x,
                           lapply(Data.zoops[variables], as.character))
  plot.mix.LD12 <- ggplot(class.train, aes(x = LD2, y = LD1, color = Type)) +
    geom_point(alpha = 0.3) +
    stat_ellipse(type = "t", alpha = 0.6) +
    geom_point(data = class.base, aes(x = LD2, y = LD1, shape = "Food Web Base"),
               color = "brown") +
    geom_point(data = class.zoops, aes(x = LD2, y = LD1, shape = "Zooplankton"),
               color = "black") +
    theme(legend.position = "none")
  # Combine tracer and LDA plots.
  ggarrange(AA_plots, plot.mix.LD12, ncol = 2, widths = c(2, 1.5),
            common.legend = TRUE, legend = "right")
}
```

# Solving food web model using MCMC {-}
Next, we will use Markov Chain Monte Carlo to find PDFs describing the most likely solutions to our mixing problem. First we will write a BUGS model, then use JAGS to do the MCMC.

## Setting up for MCMC {-}

Organizing the input data for MCMC.
```{r datalist, eval=TRUE}

N_T <- length(Tracers$all) # number of tracers
N_S <- length(Sources) # number of organic matter sources
N_Z <- nrow(Data.zoops) # number of zooplankton samples
sd.anl <- 0.52
sdTDF_scaling_factor <- 1
sdY_scaling_factor <- 1

Data.1 <- list(
  ## How many tracers will be used in this model?
  N_T = N_T,
  ## How many zooplankton samples are there?
  N_Z = N_Z,
  ## Where should the model look for zooplankton amino acid isotope data?
  Y   = as.matrix(Data.zoops[Tracers$all]),
  ## and the analytical uncertainty in those measurements
  sd_Y = as.matrix(Data.zoops[SDTracers$all])*sdY_scaling_factor,
  ## Which tracers will be used in the FWL equation and not see the data?
  i_T_FWL = which(Tracers$all %in% Tracers$FWL),
  ## Which tracers will be used in the MTS equation and not see the data?
  i_T_MTS = which(Tracers$all %in% Tracers$MTS),
  ## Which tracers will be used in the mixing model and see the data?
  i_T_mix = which(Tracers$all %in% Tracers$mix),
  ## Which tracers do not fractionate?
  i_T_non = which(Tracers$all %in% Tracers$non),
  ## Which tracers do fractionate?
  i_T_frac = which(Tracers$all %in% Tracers$frac),
  ## Which tracers have constant TDFs throughout the food web?
  i_T_const = which(Tracers$all %in% Tracers$constTDF),
  ## Which tracers have variable TDFs throughout the food web?
  i_T_var = which(Tracers$all %in% Tracers$varTDF),
  ## Where should the model look for TDF data and its associated uncertainty?
  # for metazoan TDFs
  TDF_m   = as.numeric(TDF_meta[Tracers$frac]),
  sdTDF_m = as.numeric(TDF_meta[SDTracers$frac])*sdTDF_scaling_factor,
  # for protozoan TDFs
  TDF_p   = as.numeric(TDF_proto[Tracers$frac]),
  sdTDF_p = as.numeric(TDF_proto[SDTracers$frac])*sdTDF_scaling_factor
  )

## Where should the model look for organic matter source data?
## making generalized names A-F for a max of six possible organic matter sources
Sources.alpha <- c("X_A","X_B","X_C","X_D","X_E","X_F")
SDSources.alpha <- c("sdX_A","sdX_B","sdX_C","sdX_D","sdX_E","sdX_F")
nsams_alpha   <- c("N_A","N_B","N_C","N_D","N_E","N_F")
## Loop through all sources described in setup chunks above to add that data
## to the Data.1 list as individual matrices for each source
for (i in 1:N_S) {
  sams_source <- Data.sources[Data.sources[["Group"]]==Sources[i],c(Tracers$all,SDTracers$all)]
  Data.1[[Sources.alpha[i]]] = as.matrix(sams_source[Tracers$all])
  Data.1[[SDSources.alpha[i]]] = as.double(colMeans(sams_source[SDTracers$all]))
  Data.1[[nsams_alpha[i]]]   = sum((Data.sources[["Group"]]==Sources[i])*1)
}
# Setting i_T_ vectors =0 if no tracers in that ccategory were included
if(length(Data.1$i_T_non)==0){
  Data.1$i_T_non <- 0
}
if(length(Data.1$i_T_frac)==0){
  Data.1$i_T_frac <- 0
}
if(length(Data.1$i_T_const)==0){
  Data.1$i_T_const <- 0
}
if(length(Data.1$i_T_var)==0){
  Data.1$i_T_var <- 0
}
```
and defining our initial values.
```{r initlist, eval=TRUE}
# Define MCMC initial values. Edit Nchains or ranges if adjusting MCMC settings.
set.seed(666)  # For reproducibility
Nchains <- 3   # Number of chains
inits_1 <- vector(mode = "list", length = Nchains)
# names for organic matter sources
means_alpha <- c("mean_A", "mean_B", "mean_C", "mean_D", "mean_E", "mean_F")
# and their uncertainty
sd_alpha <- c("sd_A", "sd_B", "sd_C", "sd_D", "sd_E", "sd_F")
# This function will generate starting values for each chain and save them as a list
fun_init_1 <- function(i) {
  inits <- list(
    pz = rdirichlet(n = N_Z, rep(1, N_S)),  # Mixing coefficients
    FWL = runif(n = N_Z, 1, 5),             # Food web length
    MTS = runif(n = N_Z, 0, 5),             # Metazoan trophic steps
    .RNG.seed = i + 1,
    .RNG.name = c("base::Super-Duper", "base::Wichmann-Hill", "base::Marsaglia-Multicarry")[i %% 3 + 1]
  )
  # We define starting values for sources in a separate loop so we can be flexible with the number of sources included in the model
  for (j in 1:N_S) {
    inits[[means_alpha[j]]] <- runif(N_T, -40, 20)
    inits[[sd_alpha[j]]] <- runif(N_T, 0, 2)
  }
  return(inits)
}
for (i in 1:Nchains) inits_1[[i]] <- fun_init_1(i)
```

## Drafting a BUGS model {-}
Now we'll define our BUGS model.

```{r OMSM}
# Generate the BUGS model. No edits typically needed unless modifying model structure.

if(Data.1$i_T_non[1]==0){Tracers_NoFrac <- FALSE}else{Tracers_NoFrac <- TRUE}
if(Data.1$i_T_const[1]==0){Tracers_ConstFrac <- FALSE}else{Tracers_ConstFrac <- TRUE}
if(Data.1$i_T_var[1]==0){Tracers_VarFrac <- FALSE}else{Tracers_VarFrac <- TRUE}

OMSM <- OMSM_Gen_Model(
  N_S = N_S, 
  Tracers_NoFrac = TRUE,
  Tracers_ConstFrac = TRUE,
  Tracers_VarFrac = TRUE
)
```

## Running MCMC in JAGS {-}
Now we can run the MCMC!

```{r runjags, eval=TRUE}
samsPerChain <- 2000 # needed  below for narrative, so we give it a name.
monitor_vars = c("mean_b", "mean_z",
                 "TDF_meta", "sdTDF_m",
                 "TDF_proto","sdTDF_p",
                 "pz"       , "FWL"  , "PTS", "MTS",
                 "mean_A", "sd_A",
                 "mean_B", "sd_B",
                 "mean_C", "sd_C" # remove source C if less than 3
                 # "mean_D", "sd_D", # add D, E, F, ... to monitor if more than 3
                 )

rjo_1 <- # S3 object of class "runjags"
  run.jags(model = OMSM,
           data = Data.1,
           inits = inits_1,
           silent.jags = FALSE,
           n.chains = Nchains,
           adapt  = 5000,
           burnin = 10000,
           thin = 10,
           sample = samsPerChain,
           method = "parallel",
           modules = "glm",
           monitor = monitor_vars
          )
```

## Diagnostics {-} 
Here we run some diagnostics. Initially we use John K. Kruschke's function `diagMCMC` to check out model parameters and make sure things are running properly. When these diagnostics look good, we set `eval=FALSE` in the chunk header and made a nicer parameter plot comparing known parameter values and the MCMC posteriors for those parameters, which is seen below.

```{r diagMu, eval=TRUE, fig.cap="Means of tracers 1 and 2 for prey types A,B,C."}
## Kruschke's utility functions (edited by NF)
# edit "parname" to print additional parameter diagnostics as desired
# numbers in hard brackets pertain to samples and tracers
if (c(TRUE,FALSE)[1]) source("Utilities/DBDA2E-utilities.R") 
diagMCMC(rjo_1$mcmc, parName="FWL[1]")
diagMCMC(rjo_1$mcmc, parName="MTS[1]")
diagMCMC(rjo_1$mcmc, parName="PTS[1]")
diagMCMC(rjo_1$mcmc, parName="pz[1,1]")
diagMCMC(rjo_1$mcmc, parName="pz[1,2]")
diagMCMC(rjo_1$mcmc, parName="pz[1,3]")
# diagMCMC(rjo_1$mcmc, parName="pz[1,4]")
diagMCMC(rjo_1$mcmc, parName="mean_z[1,9]")

```  

# Visualizing Results {-}
Now let's generate some data structures to store the MCMC output and other relevant data from generating plots and figures. There are a few different data types we need to get out of the MCMC output

  1. Global model parameter posteriors (TDFs, d15N(sources))
  2. Zooplankton food web parameter posteriors (mixing coefficients, trophic positions, and d15N values at the base of the food web)

We'll look at these one at a time.

## MCMC global parameter posteriors {-}

```{r MCMC_global_param_extraction, message=FALSE}
# Extract global MCMC parameters.

OMSM_Global_Extract(
    rjo_1 = rjo_1,
    Sources = Sources,
    Data.zoops = Data.zoops,
    Tracers.all = Tracers$all,
    Tracers.frac = Tracers$frac,
    Tracers.varTDF = Tracers$varTDF
)
```

Let's generate plots of the MCMC posteriors for global model parameters. Mainly here we're interested in making sure that the mean $\dNAA$ and $\dCAA$ values that the model used in mixing models agree well with the data, and looking to see what the model selected for $\DNAA$ values.

```{r global_posterior_comparisons, dpi=500, fig.asp=0.4, fig.width=8.5}
# We're going to import the literature D15N data to add to our global posterior plots for comparison
D15N_lit <- read_excel("~/University_of_Hawaii/SIA_work/EXPORTS/Data/Literature/McMahon_McCarthy_ES15-00698_Supplement1.xlsx",
    sheet = "Proto-vs-Metazoans", n_max = 21)
D15N_lit_long <- melt(D15N_lit, id.vars=c("ProMet"), measure.vars = Tracers$frac,
         variable.name="Tracer", value.name = "Value")

theme_set(theme_classic2()+
            theme(panel.grid.major.x = element_line(colour = "grey95"),
                  panel.grid.major.y = element_line(colour = "grey95")))

## Plotting posterior Δ15N values compared to true values

labels1 <- c('d15NGlx'="Glx",'d15NAsx'="Asx",'d15NAla'="Ala",'d15NIle'="Ile",'d15NLeu'="Leu",'d15NPro'="Pro",'d15NVal'="Val",'d15NGly'="Gly",'d15NSer'="Ser",'d15NPhe'="Phe",'d15NLys'="Lys",'d15NThr'="Thr")
labels2 <- c('d15NGlx'="Glx",'d15NAsx'="Asx",'d15NIle'="Ile",'d15NLeu'="Leu",'d15NVal'="Val")

## plotting posterior δ15N values for organic matter sources compared to data
plot_source <- 
  ggplot()+
  geom_density(data = posts.global.long$mean_Sources$samples[
    which(posts.global.long$mean_Sources$samples$Tracer %in% Tracers$mix),],
               aes(x=Value, fill=Group), alpha=0.8, color="grey10", size=0.5)+
  geom_point(data=Sources.long[
    which(Sources.long$Tracer %in% Tracers$mix),],
             aes(x=Value, y=0, fill=Group, shape = "Source Data"),
             color="grey10",size=2,stroke=0.75,
             show.legend = FALSE)+
  scale_shape_manual(values=c(24))+
  xlab("Value")+
  facet_wrap(~Tracer, scales = "free", nrow=2)+
  scale_x_continuous(n.breaks=4)+
  labs(fill="Organic Matter Source",color="95% HDI")+
  theme(axis.text.y = element_blank(), axis.ticks.y = element_blank(),
        axis.title.y = element_blank(),plot.title = element_text(hjust = 0.5),
        legend.position="bottom")
plot_source
```



## MCMC zooplankton parameter posteriors {-}

```{r MCMC_zoop_param_extract}
# Extract zooplankton-specific parameters. Edit 'combine' if pooling sources.

OMSM_Zoop_Extract(
    rjo_1 = rjo_1,
    Sources = Sources,
    Data.zoops = Data.zoops,
    Tracers.all = Tracers$all,
    Tracers.frac = Tracers$frac,
    Tracers.varTDF = Tracers$varTDF,
    combine = c("Surface","Large")
)

```

Now let's generate plots of the MCMC posteriors for the zooplankton sample-specific parameters. We'll want to plot the model posteriors for the tracer values at the base of the food web. We'll do this for all the individual tracers, but also try and visualize the multivariate patterns using LDA.Note that all tracers are plotted here, including those that were not used to fit the model, though those are not included in LDAs.

```{r posterior_base_comparison, dpi=300, fig.asp=0.4, fig.width=8.5}

## Generating AA δ15N comparison plot
posts.zoops.long$base$thin$Group <- as.factor(posts.zoops.long$base$thin$Group)
  
AAplots <-
  ggplot(Sources.long)+
  geom_point(aes(x = Tracer, y = Value, color = Group),
             position = position_nudge(x = 0.2))+
  geom_point(data = Zoops.long,
             aes(x = Tracer, y = Value, fill="simulated zooplankton"), pch = "triangle",
             position = position_nudge(x = -0.2))+
  geom_point(data = posts.zoops.long$base$thin[which(posts.zoops.long$base$thin$Tracer %in% Tracers$mix),],
             aes(x = Tracer, y = Value), color = "grey60", alpha=0.1, pch=16,
             position = position_dodge2(width=0.2))+
  geom_point(data = posts.zoops.long$base$mean[which(posts.zoops.long$base$mean$Tracer %in% Tracers$mix),],
             aes(x = Tracer, y = Value, shape="posterior mean"), color = "brown", alpha=1,
             position = position_dodge2(width = 0.2))+
             # position = position_nudge(x = 0.25))+
  geom_point(data = Base.long,
             aes(x = Tracer, y = Value, shape="true value"), color = "red", alpha=1,
             position = position_dodge2(width = 0.2))+
  labs(color="Organic Matter Source", shape="Food Web Base", fill="Zooplankton Samples")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.3, hjust=1))

## Generating LDA comparison plot
if(runMV == TRUE){
# poject zooplankton into LD space and predict classification
pred.base.MCMC = predict(LDA.full, 
                         posts.zoops$base$mode)
#class.zoops = data.frame('Class' = pred.zoops$class, pred.zoops$x)
# generate data frame which stores predicted classification of particles indexed by size and depth
class.base.MCMC = data.frame('Predicted' = pred.base.MCMC$class, pred.base.MCMC$x,
                             lapply(posts.zoops$base$mode[variables],as.character))
# # Predicted probabilities of class membership
# head(pred.base.MCMC$posterior,n=dim(pred.base.MCMC$posterior))
# # linear discriminants
# head(pred.base.MCMC$x,n=dim(pred.base.MCMC$x))

pred.base.sams <- predict(LDA.full,
                          posts.zoops$base$thin[Tracers$mix])
# generate data frame which stores predicted classification of particles indexed by size and depth
class.base.sams = data.frame('Predicted' = pred.base.sams$class, pred.base.sams$x,
                             lapply(posts.zoops$base$thin[variables],as.character))
# Predicted probabilities of class membership
# head(pred.base.sams$posterior,n=dim(pred.base.sams$posterior))
# linear discriminants
# head(pred.base.sams$x,n=dim(pred.base.sams$x))

plot.mix.LD12 <- 
  ggplot(data = class.train, 
                       aes(x = LD2, y = LD1), size = 2) + 
  geom_point(aes(shape=Type), alpha = 1, color="grey20") +
  stat_ellipse(aes(group=Type),type = 't', alpha = 0.8)+
  stat_ellipse(data = class.base.sams,
             aes(x = LD2, y = LD1, color=Group, fill=Group),
             type = 't', alpha = 0.5, size=0.5, geom = "polygon")+
  geom_point(data = class.base,
             aes(x = LD2, y = LD1, fill=Group, alpha = ""),
             shape=23, color="black", size=3, stroke=1)+
  scale_alpha_manual(values = c(1,1,1,1))+
  geom_point(data = class.base.MCMC,
             aes(x = LD2, y = LD1, fill=Group),
             size=3.5, shape=21, stroke=1)+
  labs(fill = "Posterior 95% HDI and Mode",
       color = "Simulated Zooplankton Sample",
       alpha = "True Value",
       shape = "Organic Matter Source"
       )+
  guides(color=FALSE)
  ggarrange(AAplots, plot.mix.LD12, ncol = 2, widths = c(2, 1.5),
            common.legend = TRUE, legend = "left")
}else {
  AAplots
}

```

We also want to look at the mean_z parameter for each zooplankton sample to see if and where the posteriors are deviating from the data.

```{r posterior_zoop, dpi=300, fig.asp=0.6, fig.width=8.5}

## Generating AA δ15N comparison plot
posts.zoops.long$zoop$thin$Group <- as.factor(posts.zoops.long$zoop$thin$Group)
  
AAplots <-
  ggplot(Sources.long)+
  geom_point(aes(x = Tracer, y = Value, color = Group),
             position = position_nudge(x = 0.2))+
  geom_point(data = Zoops.long,
             aes(x = Tracer, y = Value, fill="simulated zooplankton"), pch = "triangle",
             position = position_nudge(x = -0.2))+
  geom_point(data = posts.zoops.long$zoop$thin[which(posts.zoops.long$zoop$thin$Tracer %in% Tracers$mix),],
             aes(x = Tracer, y = Value), color = "grey60", alpha=0.1, pch=16,
             position = position_dodge2(width=0.1))+
  geom_point(data = posts.zoops.long$zoop$mean[which(posts.zoops.long$zoop$mean$Tracer %in% Tracers$mix),],
             aes(x = Tracer, y = Value, shape="posterior mean"), color = "brown", alpha=1,
             position = position_dodge2(width = 0.1))+
  labs(color="Organic Matter Source", shape="Zooplankton Posterior", fill="Zooplankton Samples")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.3, hjust=1))
AAplots

```

We also want to plot comparisons of the trophic parameters used to simulate the zooplankton data and the model posteriors for those parameters.

```{r posterior_trophic_comparison, dpi=300, fig.asp=0.5, fig.width=8.5}
posts.zoops$trophic$samples$model <- as.factor("vague prior")
posts.zoops$trophic$samples$Group <- as.factor(posts.zoops$trophic$samples$Group)

plot.FWL <-
  ggplot()+
  geom_line(data = posts.zoops$trophic$HDI95,
            aes(x = Group, y = FWL, group = Group),
            alpha = 0.5, size = 1, color = "steelblue4")+
  geom_line(data = posts.zoops$trophic$HDI90,
            aes(x = Group, y = FWL, group = Group),
            alpha = 0.7, size = 1.5, color = "steelblue4")+
  geom_line(data = posts.zoops$trophic$HDI75,
            aes(x = Group, y = FWL, group = Group),
            alpha = 0.9, size = 2, color = "steelblue4")+
  geom_line(data = posts.zoops$trophic$HDI50,
            aes(x = Group, y = FWL, group = Group),
            alpha = 1, size = 3, color = "steelblue4")+
  geom_text(data = posts.zoops$trophic$mode,
            aes(x = Group, y = FWL, group = Group, 
                label = round(FWL,1)),
            size = 1.6, color = "lightskyblue1")+
  scale_linetype_manual(values=c(1,1))+
  geom_segment(
    aes(y=zoops.f$FWL, x=seq(1,nzoops)-0.5, xend=seq(1,nzoops)+0.5,
        color=""),
    lty=1,size=0.5,alpha=1)+
  scale_color_manual(values=c("goldenrod"))+
  labs(fill="Model Posterior", color="True Value",lty="95% HDI")+
  xlab("Simulated Zooplankton Sample") + ylab("FWL")+
  scale_x_continuous(breaks = seq(1,nzoops,2))+
  coord_cartesian(ylim = c(0,3.5), xlim = c(0,nzoops+1), expand = FALSE)
plot.PTS <-
  ggplot()+
  geom_line(data = posts.zoops$trophic$HDI95,
            aes(x = Group, y = PTS, group = Group),
            alpha = 0.5, size = 1, color = "steelblue4")+
  geom_line(data = posts.zoops$trophic$HDI90,
            aes(x = Group, y = PTS, group = Group),
            alpha = 0.7, size = 1.5, color = "steelblue4")+
  geom_line(data = posts.zoops$trophic$HDI75,
            aes(x = Group, y = PTS, group = Group),
            alpha = 0.9, size = 2, color = "steelblue4")+
  geom_line(data = posts.zoops$trophic$HDI50,
            aes(x = Group, y = PTS, group = Group),
            alpha = 1, size = 3, color = "steelblue4")+
  geom_text(data = posts.zoops$trophic$mode,
            aes(x = Group, y = PTS, group = Group, 
                label = round(PTS,1)),
            size = 1.6, color = "lightskyblue1")+
  scale_linetype_manual(values=c(1,1))+
  geom_segment(
    aes(y=zoops.f$PTS, x=seq(1,nzoops)-0.5, xend=seq(1,nzoops)+0.5,
        color=""),
    lty=1,size=0.5,alpha=1)+
  scale_color_manual(values=c("goldenrod"))+
  labs(fill="Model Posterior", color="True Value",lty="95% HDI")+
  xlab("Simulated Zooplankton Sample") + ylab("PTS") + labs(lty="",shape="",color="")+
  scale_y_continuous(breaks = c(0,1,2,3,4))+
  scale_x_continuous(breaks = seq(1,nzoops,2))+
  coord_cartesian(ylim = c(-0.5,2), xlim = c(0,nzoops+1), expand = FALSE)
plot.MTS <-
  ggplot()+
  geom_line(data = posts.zoops$trophic$HDI95,
            aes(x = Group, y = MTS, group = Group),
            alpha = 0.5, size = 1, color = "steelblue4")+
  geom_line(data = posts.zoops$trophic$HDI90,
            aes(x = Group, y = MTS, group = Group),
            alpha = 0.7, size = 1.5, color = "steelblue4")+
  geom_line(data = posts.zoops$trophic$HDI75,
            aes(x = Group, y = MTS, group = Group),
            alpha = 0.9, size = 2, color = "steelblue4")+
  geom_line(data = posts.zoops$trophic$HDI50,
            aes(x = Group, y = MTS, group = Group),
            alpha = 1, size = 3, color = "steelblue4")+
  geom_text(data = posts.zoops$trophic$mode,
            aes(x = Group, y = MTS, group = Group, 
                label = round(MTS,1)),
            size = 1.6, color = "lightskyblue1")+
  scale_linetype_manual(values=c(1,1))+
  geom_segment(
    aes(y=zoops.f$MTS, x=seq(1,nzoops)-0.5, xend=seq(1,nzoops)+0.5,
        color=""),
    lty=1,size=0.5,alpha=1)+
  scale_color_manual(values=c("goldenrod"))+
  labs(fill="Model Posterior", color="True Value",lty="95% HDI")+
  xlab("Simulated Zooplankton Sample") + ylab("MTS") + labs(lty="",shape="",color="")+
  scale_y_continuous(breaks = c(0,1,2,3,4))+
  scale_x_continuous(breaks = seq(1,nzoops,2))+
  coord_cartesian(ylim = c(0,2.5), xlim = c(0,nzoops+1), expand = FALSE)

ggarrange(
  plot.PTS + no.x.axis,
  plot.MTS + no.x.axis,
  plot.FWL,
  nrow=3, heights = c(2,2,3), common.legend = TRUE , legend="right")
```

```{r error-quantification-trophic}

data.true <- zoops.f[c("PTS","MTS","FWL")]

data.model <- posts.zoops$trophic$mode[c("PTS","MTS","FWL")]

troph.disc <- data.model-data.true
troph.disc$Model <- "OMSM" # posts.zoops.mode$Model
troph.disc$Model <- factor(troph.disc$Model, levels = c("OMSM",
                                                      "MM(Phe,Lys)",
                                                      "MM(Ser,Gly,Phe,Lys)"))

troph.disc.abs <- abs(troph.disc[c("PTS","MTS","FWL")])
troph.disc.abs$Model <- troph.disc$Model

troph.disc.sum <- aggregate(.~Model,
                            data=troph.disc.abs,
                            FUN=sum)
troph.disc.sum

troph.disc.mean <- aggregate(.~Model,
                            data=troph.disc.abs,
                            FUN=mean)
troph.disc.mean

data.true.long <-
  melt(
      data.true,
      value.name = "true_value",
      variable.name = "Parameter"
    )
data.model.long <- 
  melt(
      data.model,
      value.name = "model_value",
      variable.name = "Parameter"
    )

data.truemod.long <-
  cbind(
    data.true.long,
    data.model.long[,"model_value"])
colnames(data.truemod.long) <-
  c("parameter","true_value","model_value")

data.truemod.long$disc <-
  data.truemod.long$model_value -
  data.truemod.long$true_value

ggplot(data = data.truemod.long)+
  geom_abline(slope = 1, intercept = 0, size = 1)+
  geom_point(
    aes(x = true_value, y = model_value,
        color = parameter), shape = 1,
    position = position_dodge(width = 0.2),
    size = 2
  )+
  geom_smooth(
    aes(x = true_value, y = model_value,
        color = parameter, fill = parameter),
    method = "lm"
    # method = "glm", method.args = list(family = quasibinomial())
  )+
  coord_cartesian(expand = FALSE)

ggplot(data = data.truemod.long,)+
  geom_abline(slope = 0, intercept = 0, size = 1)+
  geom_point(
    aes(x = true_value, y = disc,
        color = parameter, group = parameter),
    position = position_dodge(width = 0.05),
    size = 2, stroke=1, shape = 1
  )+
  geom_smooth(
    aes(x = true_value, y = disc,
        color = parameter, fill = parameter),
    method = "lm"
    # method = "glm", method.args = list(family = binomial())
  )+
  coord_cartesian(ylim = c(-1,1),expand = FALSE)

plot.TM.FWL <-
  ggplot(data = subset(data.truemod.long, parameter == "FWL"))+
  geom_point(
    aes(x = true_value, y = model_value),
    size = 1, stroke=1, shape = 1, color = "steelblue4"
  )+
  geom_smooth(
    aes(x = true_value, y = model_value),
        color = "royalblue4", fill = "skyblue1",
    method = "lm"
    # method = "glm", method.args = list(family = binomial())
  )+
  geom_abline(slope = 1, intercept = 0, size = 0.5, color = "goldenrod")+
  coord_cartesian(ylim = c(0,3.5), xlim = c(0,3.5), expand = FALSE)+
  scale_y_continuous(breaks = c(0,1,2,3,4))+
  scale_x_continuous(breaks = c(0,1,2,3,4))
plot.TM.PTS <-
  ggplot(data = subset(data.truemod.long, parameter == "PTS"))+
  geom_point(
    aes(x = true_value, y = model_value),
    size = 1, stroke=1, shape = 1, color = "steelblue4"
  )+
  geom_smooth(
    aes(x = true_value, y = model_value),
        color = "royalblue4", fill = "skyblue1",
    method = "lm"
    # method = "glm", method.args = list(family = binomial())
  )+
  geom_abline(slope = 1, intercept = 0, size = 0.5, color = "goldenrod")+
  coord_cartesian(ylim = c(-0.5,2), xlim = c(-0.5,2), expand = FALSE)+
  scale_y_continuous(breaks = c(0,1,2,3,4))+
  scale_x_continuous(breaks = c(0,1,2,3,4))
plot.TM.MTS <-
  ggplot(data = subset(data.truemod.long, parameter == "MTS"))+
  geom_point(
    aes(x = true_value, y = model_value),
    size = 1, stroke=1, shape = 1, color = "steelblue4"
  )+
  geom_smooth(
    aes(x = true_value, y = model_value),
        color = "royalblue4", fill = "skyblue1",
    method = "lm"
    # method = "glm", method.args = list(family = binomial())
  )+
  geom_abline(slope = 1, intercept = 0, size = 0.5, color = "goldenrod")+
  coord_cartesian(ylim = c(0,2.5), xlim = c(0,2.5), expand = FALSE)+
  scale_y_continuous(breaks = c(0,1,2,3,4))+
  scale_x_continuous(breaks = c(0,1,2,3,4))

plot.TM.FWLdisc <-
  ggplot(data = subset(data.truemod.long, parameter == "FWL"))+
  geom_point(
    aes(x = true_value, y = disc),
    size = 1, stroke=1, shape = 1, color = "steelblue4"
  )+
  geom_smooth(
    aes(x = true_value, y = disc),
        color = "royalblue4", fill = "skyblue1",
    method = "lm"
    # method = "glm", method.args = list(family = binomial())
  )+
  geom_abline(slope = 0, intercept = 0, size = 0.5, color = "goldenrod")+
  coord_cartesian(ylim = c(-1,1), xlim = c(1,3), expand = FALSE)+
  scale_x_continuous(breaks = c(0,1,2,3,4))
plot.TM.PTSdisc <-
  ggplot(data = subset(data.truemod.long, parameter == "PTS"))+
  geom_point(
    aes(x = true_value, y = disc),
    size = 1, stroke=1, shape = 1, color = "steelblue4"
  )+
  geom_smooth(
    aes(x = true_value, y = disc),
        color = "royalblue4", fill = "skyblue1",
    method = "lm"
    # method = "glm", method.args = list(family = binomial())
  )+
  geom_abline(slope = 0, intercept = 0, size = 0.5, color = "goldenrod")+
  coord_cartesian(ylim = c(-1,1), xlim = c(0,1), expand = FALSE)+
  scale_x_continuous(breaks = c(0,1,2,3,4))
plot.TM.MTSdisc <-
  ggplot(data = subset(data.truemod.long, parameter == "MTS"))+
  geom_point(
    aes(x = true_value, y = disc),
    size = 1, stroke=1, shape = 1, color = "steelblue4"
  )+
  geom_smooth(
    aes(x = true_value, y = disc),
        color = "royalblue4", fill = "skyblue1",
    method = "lm"
    # method = "glm", method.args = list(family = binomial())
  )+
  geom_abline(slope = 0, intercept = 0, size = 0.5, color = "goldenrod")+
  coord_cartesian(ylim = c(-1,1), xlim = c(1,2), expand = FALSE)+
  scale_x_continuous(breaks = c(0,1,2,3,4))
  
# plot.TM.PTS
# plot.TM.MTS
# plot.TM.FWL

```

Last we'll do the same for mixing parameters. Here we'll generate simple box plots, but also ternary plots with two of the four organic matter sources pooled on one axis.

```{r posterior_f_ternary, eval=FALSE, dpi=300, fig.asp=0.82, fig.width=8.5}

## Making ternary plots of mixing parameters
posts.zoops$f$samples$Group <- as.numeric(posts.zoops$f$samples$Group)

ggtern(data = posts.zoops$f$samples,
       aes(x=Surface,
           y=Large,
           z=Small))+
  stat_confidence_tern(aes(fill="HDI"), color="grey20", alpha=0.4, size=0,
                       breaks=c(0.95,0.9,0.75,0.5), geom = "polygon")+
  scale_fill_manual(values=c("steelblue4","steelblue1"))+
  geom_point(data = posts.zoops$f$mode, 
             aes(x=Surface,
                 y=Large,
                 z=Small,
                 fill="Mode"),
             color="grey10",size=3, stroke=1, shape=21)+
  geom_point(data = zoops.sim, 
             aes(x=Surface,
                 y=Large,
                 z=Small,
                 shape=""),
             color="grey10",size=3, stroke=1, fill="goldenrod")+
  scale_shape_manual(values=c(24))+
  theme_bw() + 
  theme_nomask()+
  theme_arrowcustomlength(start = c(0.1,0.1,0.1), finish = c(0.9,0.9,0.9))+
  theme(legend.box="vertical",
        legend.position = "right",
        tern.axis.title.T=element_blank(),
        tern.axis.title.L=element_blank(),
        tern.axis.title.R=element_blank())+
  labs(fill="Model Posterior",shape="True Value",color="95% HDI")+
  facet_wrap(~Group, nrow = round(sqrt(nrow(zoops.f)),0))+
  scale_L_continuous(breaks = c(0,1))+
  scale_R_continuous(breaks = c(0,1))+
  scale_T_continuous(breaks = c(0,1))




```

```{r posterior_f_comparisons, eval=TRUE, dpi=300, fig.asp=0.5, fig.width=8.5}
theme_set(theme_classic2()+
            theme(panel.grid.major.x = element_line(colour = "grey95"),
                  panel.grid.major.y = element_line(colour = "grey95")))

nzoops=zoops.n

posts.zoops$f$samples$Group <- as.character(posts.zoops$f$samples$Group)


plot.Surface <-
  ggplot()+
  scale_fill_manual(values=c("steelblue1","steelblue4"))+
  geom_line(data = posts.zoops$f$HDI95,
            aes(x = Group, y = Surface, group = Group),
            alpha = 0.5, size = 1, color = "steelblue4")+
  geom_line(data = posts.zoops$f$HDI90,
            aes(x = Group, y = Surface, group = Group),
            alpha = 0.7, size = 1.5, color = "steelblue4")+
  geom_line(data = posts.zoops$f$HDI75,
            aes(x = Group, y = Surface, group = Group),
            alpha = 0.9, size = 2, color = "steelblue4")+
  geom_line(data = posts.zoops$f$HDI50,
            aes(x = Group, y = Surface, group = Group),
            alpha = 1, size = 3, color = "steelblue4")+
  geom_text(data = posts.zoops$f$mode,
            aes(x = Group, y = Surface, group = Group, 
                label = round(Surface*100,0)),
            size = 1.6, color = "lightskyblue1")+
  geom_segment(
    aes(y=zoops.f$Surface, x=seq(1,nzoops)-0.5, xend=seq(1,nzoops)+0.5,
        color=""),
    lty=1,size=0.5,alpha=1)+
  scale_color_manual(values=c("goldenrod"))+
  labs(fill="Model Posterior", color="True Value", lty="95% HDI")+
  xlab("Simulated Zooplankton Sample") + ylab("f(surface)") +
  scale_y_continuous(breaks = c(0,0.25,0.5,0.75,1), labels = c("0","","0.5","","1.0"))+
  scale_x_continuous(breaks = seq(1,nzoops,2))+
  coord_cartesian(ylim = c(0,1), xlim = c(0,nzoops+1), expand = FALSE)
plot.Large <-
  ggplot()+
  scale_fill_manual(values=c("steelblue1","steelblue4"))+
  geom_line(data = posts.zoops$f$HDI95,
            aes(x = Group, y = Large, group = Group),
            alpha = 0.5, size = 1, color = "steelblue4")+
  geom_line(data = posts.zoops$f$HDI90,
            aes(x = Group, y = Large, group = Group),
            alpha = 0.7, size = 1.5, color = "steelblue4")+
  geom_line(data = posts.zoops$f$HDI75,
            aes(x = Group, y = Large, group = Group),
            alpha = 0.9, size = 2, color = "steelblue4")+
  geom_line(data = posts.zoops$f$HDI50,
            aes(x = Group, y = Large, group = Group),
            alpha = 1, size = 3, color = "steelblue4")+
  geom_text(data = posts.zoops$f$mode,
            aes(x = Group, y = Large, group = Group, 
                label = round(Large*100,0)),
            size = 1.6, color = "lightskyblue1")+
  geom_segment(
    aes(y=zoops.f$Large, x=seq(1,nzoops)-0.5, xend=seq(1,nzoops)+0.5,
        color=""),
    lty=1,size=0.5,alpha=1)+
  scale_color_manual(values=c("goldenrod"))+
  labs(fill="Model", color="Actual")+
  xlab("Simulated Zooplankton Sample") + ylab("f(large)") +
  scale_y_continuous(breaks = c(0,0.25,0.5,0.75,1), labels = c("0","","0.5","","1.0"))+
  scale_x_continuous(breaks = seq(1,nzoops,2))+
  coord_cartesian(ylim = c(0,1), xlim = c(0,nzoops+1), expand = FALSE)
plot.Small <-
  ggplot()+
  scale_fill_manual(values=c("steelblue1","steelblue4"))+
  geom_line(data = posts.zoops$f$HDI95,
            aes(x = Group, y = Small, group = Group),
            alpha = 0.5, size = 1, color = "steelblue4")+
  geom_line(data = posts.zoops$f$HDI90,
            aes(x = Group, y = Small, group = Group),
            alpha = 0.7, size = 1.5, color = "steelblue4")+
  geom_line(data = posts.zoops$f$HDI75,
            aes(x = Group, y = Small, group = Group),
            alpha = 0.9, size = 2, color = "steelblue4")+
  geom_line(data = posts.zoops$f$HDI50,
            aes(x = Group, y = Small, group = Group),
            alpha = 1, size = 3, color = "steelblue4")+
  geom_text(data = posts.zoops$f$mode,
            aes(x = Group, y = Small, group = Group, 
                label = round(Small*100,0)),
            size = 1.6, color = "lightskyblue1")+
  geom_segment(
    aes(y=zoops.f$Small, x=seq(1,nzoops)-0.5, xend=seq(1,nzoops)+0.5,
        color=""),
    lty=1,size=0.5,alpha=1)+
  scale_color_manual(values=c("goldenrod"))+
  labs(fill="Model", color="Actual")+
  xlab("Simulated Zooplankton Sample") + ylab("f(small)") +
  scale_y_continuous(breaks = c(0,0.25,0.5,0.75,1), labels = c("0","","0.5","","1.0"))+
  scale_x_continuous(breaks = seq(1,nzoops,2))+
  coord_cartesian(ylim = c(0,1), xlim = c(0,nzoops+1), expand = FALSE)
plot.SurfaceLarge <-
  ggplot()+
  scale_fill_manual(values=c("steelblue1","steelblue4"))+
  geom_line(data = posts.zoops$f$HDI95,
            aes(x = Group, y = SurfaceLarge, group = Group),
            alpha = 0.5, size = 1, color = "steelblue4")+
  geom_line(data = posts.zoops$f$HDI90,
            aes(x = Group, y = SurfaceLarge, group = Group),
            alpha = 0.7, size = 1.5, color = "steelblue4")+
  geom_line(data = posts.zoops$f$HDI75,
            aes(x = Group, y = SurfaceLarge, group = Group),
            alpha = 0.9, size = 2, color = "steelblue4")+
  geom_line(data = posts.zoops$f$HDI50,
            aes(x = Group, y = SurfaceLarge, group = Group),
            alpha = 1, size = 3, color = "steelblue4")+
  geom_text(data = posts.zoops$f$mode,
            aes(x = Group, y = SurfaceLarge, group = Group, 
                label = round(SurfaceLarge*100,0)),
            size = 1.6, color = "lightskyblue1")+
  geom_segment(
    aes(y=zoops.f$Surface + zoops.f$Large, x=seq(1,nzoops)-0.5, xend=seq(1,nzoops)+0.5,
        color=""),
    lty=1,size=0.5,alpha=1)+
  scale_color_manual(values=c("goldenrod"))+
  labs(fill="Model Posterior", color="True Value", lty="95% HDI")+
  xlab("Simulated Zooplankton Sample") + ylab("f(surface + large)") +
  scale_y_continuous(breaks = c(0,0.25,0.5,0.75,1), labels = c("0","","0.5","","1.0"))+
  scale_x_continuous(breaks = seq(1,nzoops,2))+
  coord_cartesian(ylim = c(0,1), xlim = c(0,nzoops+1), expand = FALSE)


  ggarrange(
    plot.Surface + no.x.axis,
    plot.Large + no.x.axis,
    plot.Small,
    nrow = 3, ncol = 1, heights = c(1,1,1.1), legend = "none", common.legend = TRUE)

```

Finally, we're going to try and quantify model accuracy.

```{r error-quantification-mixing, dpi=300, fig.width=6, fig.asp=0.6}

data.true <- zoops.f[c("Surface","Large","Small")]
data.true$SurfaceLarge <- zoops.f$Large + zoops.f$Surface
data.model <- 
  cbind(
    posts.zoops$f$mode[c("Surface","Large","Small","SurfaceLarge")]
  )

mix.disc <- data.model-data.true
mix.disc$Model <- "OMSM" # posts.zoops.mode$Model
mix.disc$Model <- factor(mix.disc$Model, levels = c("OMSM",
                                                      "MM(Phe,Lys)",
                                                      "MM(Ser,Gly,Phe,Lys)"))

mix.disc.abs <- abs(mix.disc[c("Surface","Large","Small","SurfaceLarge")])
mix.disc.abs$Model <- mix.disc$Model

mix.disc.sum <- aggregate(.~Model,
                            data=mix.disc.abs,
                            FUN=sum)
mix.disc.sum

mix.disc.mean <- aggregate(.~Model,
                            data=mix.disc.abs,
                            FUN=mean)
mix.disc.mean

print("max absolute discrepancy - Surface")
max(mix.disc.abs$Surface)
print("max absolute discrepancy - Large")
max(mix.disc.abs$Large)
print("max absolute discrepancy - Small")
max(mix.disc.abs$Small)

data.model.long <- 
  melt(data.model[Sources], 
       value.name = "f_model",
       variable.name = "Source"
  )
data.true.long <- 
  melt(data.true[Sources], 
       value.name = "f_true",
       variable.name = "Source"
  )
data.truemod.long <-
  cbind(
    data.true.long,
    data.model.long["f_model"]
  )
data.truemod.long$f_disc <-
  data.truemod.long$f_model -
  data.truemod.long$f_true


ggplot(data = data.truemod.long,)+
  geom_abline(slope = 1, intercept = 0, size = 1)+
  geom_point(
    aes(x = f_true, y = f_model,
        color = Source, group = Source),
    position = position_dodge(width = 0.05),
    size = 2, stroke=1, shape = 1
  )+
  geom_smooth(
    aes(x = f_true, y = f_model,
        color = Source, fill = Source),
    # method = "lm"
    method = "glm", method.args = list(family = binomial())
  )+
  coord_cartesian(ylim = c(0,1), expand = FALSE)

ggplot(data = data.truemod.long,)+
  geom_abline(slope = 0, intercept = 0, size = 1)+
  geom_point(
    aes(x = f_true, y = f_disc,
        color = Source, group = Source),
    position = position_dodge(width = 0.05),
    size = 2, stroke=1, shape = 1
  )+
  geom_smooth(
    aes(x = f_true, y = f_disc,
        color = Source, fill = Source),
    method = "lm"
    # method = "glm", method.args = list(family = binomial())
  )+
  coord_cartesian(ylim = c(-1,1),expand = FALSE)

plot.TM.surf <-
  ggplot(data = subset(data.truemod.long, Source == "Surface"))+
  geom_point(
    aes(x = f_true, y = f_model),
    size = 1, stroke=1, shape = 1, color = "steelblue4"
  )+
  geom_smooth(
    aes(x = f_true, y = f_model),
        color = "royalblue4", fill = "skyblue1",
    # method = "lm"
    method = "glm", method.args = list(family = binomial())
  )+
  geom_abline(slope = 1, intercept = 0, size = 0.5, color = "goldenrod")+
  coord_cartesian(ylim = c(0,1), xlim = c(0,1), expand = FALSE)+
  scale_x_continuous(breaks = c(0,0.5,1))+
  scale_y_continuous(breaks = c(0,0.5,1))
plot.TM.large <-
  ggplot(data = subset(data.truemod.long, Source == "Large"))+
  geom_point(
    aes(x = f_true, y = f_model),
    size = 1, stroke=1, shape = 1, color = "steelblue4"
  )+
  geom_smooth(
    aes(x = f_true, y = f_model),
        color = "royalblue4", fill = "skyblue1",
    # method = "lm"
    method = "glm", method.args = list(family = binomial())
  )+
  geom_abline(slope = 1, intercept = 0, size = 0.5, color = "goldenrod")+
  coord_cartesian(ylim = c(0,1), xlim = c(0,1), expand = FALSE)+
  scale_x_continuous(breaks = c(0,0.5,1))+
  scale_y_continuous(breaks = c(0,0.5,1))
plot.TM.small <-
  ggplot(data = subset(data.truemod.long, Source == "Small"))+
  geom_point(
    aes(x = f_true, y = f_model),
    size = 1, stroke=1, shape = 1, color = "steelblue4"
  )+
  geom_smooth(
    aes(x = f_true, y = f_model),
        color = "royalblue4", fill = "skyblue1",
    # method = "lm"
    method = "glm", method.args = list(family = binomial())
  )+
  geom_abline(slope = 1, intercept = 0, size = 0.5, color = "goldenrod")+
  coord_cartesian(ylim = c(0,1), xlim = c(0,1), expand = FALSE)+
  scale_x_continuous(breaks = c(0,0.5,1))+
  scale_y_continuous(breaks = c(0,0.5,1))


plot.TM.surfdisc <-
  ggplot(data = subset(data.truemod.long, Source == "Surface"))+
  geom_point(
    aes(x = f_true, y = f_disc),
    size = 1, stroke=1, shape = 1, color = "steelblue4"
  )+
  geom_smooth(
    aes(x = f_true, y = f_disc),
        color = "royalblue4", fill = "skyblue1",
    method = "lm"
    # method = "glm", method.args = list(family = binomial())
  )+
  geom_abline(slope = 0, intercept = 0, size = 0.5, color = "goldenrod")+
  coord_cartesian(ylim = c(-1,1), xlim = c(0,1), expand = FALSE)+
  scale_x_continuous(breaks = c(0,0.5,1))+
  scale_y_continuous(breaks = c(-1,-0.5,0,0.5,1))
plot.TM.largedisc <-
  ggplot(data = subset(data.truemod.long, Source == "Large"))+
  geom_point(
    aes(x = f_true, y = f_disc),
    size = 1, stroke=1, shape = 1, color = "steelblue4"
  )+
  geom_smooth(
    aes(x = f_true, y = f_disc),
        color = "royalblue4", fill = "skyblue1",
    method = "lm"
    # method = "glm", method.args = list(family = binomial())
  )+
  geom_abline(slope = 0, intercept = 0, size = 0.5, color = "goldenrod")+
  coord_cartesian(ylim = c(-1,1), xlim = c(0,1), expand = FALSE)+
  scale_x_continuous(breaks = c(0,0.5,1))+
  scale_y_continuous(breaks = c(-1,-0.5,0,0.5,1))
plot.TM.smalldisc <-
  ggplot(data = subset(data.truemod.long, Source == "Small"))+
  geom_point(
    aes(x = f_true, y = f_disc),
    size = 1, stroke=1, shape = 1, color = "steelblue4"
  )+
  geom_smooth(
    aes(x = f_true, y = f_disc),
        color = "royalblue4", fill = "skyblue1",
    method = "lm"
    # method = "glm", method.args = list(family = binomial())
  )+
  geom_abline(slope = 0, intercept = 0, size = 0.5, color = "goldenrod")+
  coord_cartesian(ylim = c(-1,1), xlim = c(0,1), expand = FALSE)+
  scale_x_continuous(breaks = c(0,0.5,1))+
  scale_y_continuous(breaks = c(-1,-0.5,0,0.5,1))
```

We'll also draw up a full page figure showing mixing model and trophic parameter posteriors for all samples.

```{r mix-troph-post-summary, fig.width=8, fig.asp=1, dpi=300}

ggarrange(
  
  ggarrange(
    ggplot()+
      ggtitle("Posterior Mode and HDI by Sample")+
      theme(plot.title = element_text(hjust = 0.6)),
    ggplot()+
      ggtitle("Modelled\nvs True")+
      theme(plot.title = element_text(hjust = 0.5)),
    ggplot()+
      ggtitle("Discrepancy")+
      theme(plot.title = element_text(hjust = 1)),
    ncol = 3, widths = c(4,0.8,1)
  ),
  
  ggarrange(
    plot.Surface + 
    theme(axis.title.x = element_blank()),
      plot.TM.surf + no.y.axis +
      theme(axis.title.x = element_blank(),axis.title.y = element_blank()),
        plot.TM.surfdisc + 
        theme(axis.title.x = element_blank(),axis.title.y = element_blank()),
    plot.Large + 
    theme(axis.title.x = element_blank()),
      plot.TM.large + no.y.axis +
      theme(axis.title.x = element_blank(),axis.title.y = element_blank()),
        plot.TM.largedisc + 
        theme(axis.title.x = element_blank(),axis.title.y = element_blank()),
    plot.Small + 
    theme(axis.title.x = element_blank()),
      plot.TM.small + no.y.axis +
      theme(axis.title.x = element_blank(),axis.title.y = element_blank()),
        plot.TM.smalldisc + 
        theme(axis.title.x = element_blank(),axis.title.y = element_blank()),
    nrow = 3, ncol = 3, heights = c(1,1,1), widths = c(4,0.8,1), legend = "none"),
  
  ggarrange(
    ggplot()+
      geom_blank(),
    ggarrange(
      plot.PTS + 
      theme(axis.title.x = element_blank()),
        plot.TM.PTS + no.y.axis +
        theme(axis.title.x = element_blank(),axis.title.y = element_blank()),
          plot.TM.PTSdisc + 
          theme(axis.title.x = element_blank(),axis.title.y = element_blank()),
      plot.MTS + 
      theme(axis.title.x = element_blank()),
        plot.TM.MTS + no.y.axis +
        theme(axis.title.x = element_blank(),axis.title.y = element_blank()),
          plot.TM.MTSdisc + 
          theme(axis.title.x = element_blank(),axis.title.y = element_blank()),
      plot.FWL,
        plot.TM.FWL + no.y.axis +
        theme(axis.title.y = element_blank()) + 
        xlab("True Value"),
          plot.TM.FWLdisc + 
          theme(axis.title.y = element_blank()) + 
          xlab("True Value"),
      nrow=3, ncol=3, heights = c(5,5,6), widths = c(4,0.8,1),
      legend="none"),
    ncol = 2, widths = c(0.018,1)
  ),
  
  nrow = 3, heights = c(0.15,1,1)
  
)
```

The last things we want to do here is export out mixing model results to a viewable table and a .xlsx file.

```{r f-vs-TP, fig.width=4, fig.asp=1.5, dpi=300}
  
f_surface.mode <- posts.zoops$f$mode$Surface
MTS.mode <- posts.zoops$trophic$mode$MTS
# Size <- posts.zoops$trophic$mode$Size
model <- lm(MTS.mode ~ f_surface.mode)
# plot(allEffects(mod=model))
anova(model)
  
f_surface.mode <- posts.zoops$f$mode$Surface
PTS.mode <- posts.zoops$trophic$mode$PTS
# Size <- posts.zoops$trophic$mode$Size
model <- lm(PTS.mode ~ f_surface.mode)
# plot(allEffects(mod=model))
anova(model)

f_surface.mode <- posts.zoops$f$mode$Surface
FWL.mode <- posts.zoops$trophic$mode$FWL
# Size <- posts.zoops$trophic$mode$Size
model <- glm(f_surface.mode ~ FWL.mode, quasibinomial)
# plot(allEffects(mod=model))
anova(model)

## FWL ##
plot.disc.FWL <-
  ggplot() +
  # geom_point(aes(x = posts.zoops$f$thin$Surface, y = posts.zoops$trophic$thin$FWL),
  #            shape=1, alpha=0.5, size=0.2)+
  geom_smooth(aes(x = zoops.f$Surface, y = troph.disc$FWL),
              method = "lm",
              color = "royalblue4", fill = "skyblue1")+
  geom_point(aes(x = zoops.f$Surface, y = troph.disc$FWL),
             shape = 21 ,size=2, fill = "steelblue4")+
  theme(legend.position = "none")+
  coord_cartesian(ylim = c(-1,1), xlim = c(0,1), expand = FALSE)+
  xlab("f(surface)")+
  ylab("FWL")

## FWL ##
plot.disc.MTS <-
  ggplot() +
  # geom_point(aes(x = posts.zoops$f$thin$Surface, y = posts.zoops$trophic$thin$FWL),
  #            shape=1, alpha=0.5, size=0.2)+
  geom_smooth(aes(x = zoops.f$Surface, y = troph.disc$MTS),
              method = "lm",
              color = "royalblue4", fill = "skyblue1")+
  geom_point(aes(x = zoops.f$Surface, y = troph.disc$MTS),
             shape = 21 ,size=2, fill = "steelblue4")+
  theme(legend.position = "none")+
  coord_cartesian(ylim = c(-1,1), xlim = c(0,1), expand = FALSE)+
  xlab("f(surface)")+
  ylab("MTS")

## PTS ##
plot.disc.PTS <-
  ggplot() +
  # geom_point(aes(x = posts.zoops$f$thin$Surface, y = posts.zoops$trophic$thin$FWL),
  #            shape=1, alpha=0.5, size=0.2)+
  geom_smooth(aes(x = zoops.f$Surface, y = troph.disc$PTS),
              method = "lm",
              color = "royalblue4", fill = "skyblue1")+
  geom_point(aes(x = zoops.f$Surface, y = troph.disc$PTS),
             shape = 21 ,size=2, fill = "steelblue4")+
  theme(legend.position = "none")+
  coord_cartesian(ylim = c(-1,1), xlim = c(0,1), expand = FALSE)+
  xlab("f(surface)")+
  ylab("PTS")

ggarrange(
  ggplot()+
    geom_blank()+
    ggtitle("Posterior Mode - True Value                          ")+
    theme(plot.title = element_text(angle = 90)),
  ggarrange(
    plot.disc.PTS + no.x.axis,
    plot.disc.MTS + no.x.axis,
    plot.disc.FWL,
    ncol=1, heights = c(1,1,1.25)
  ),
  ncol = 2, widths = c(0.1,1)
)


```

```{r export-results, eval=FALSE}
save(posts.global, posts.global.long, 
     posts.zoops, posts.zoops.long, 
     Data.all, zoops.sim, zoops.f,
     file = "OSPsim_OMSM1_posteriors.RData")
```



